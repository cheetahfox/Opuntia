--- /dev/null
+++ b/package/base-files/files/lib/functions/uci-defaults-new.sh
@@ -0,0 +1,438 @@
+#!/bin/ash
+
+CFG=/etc/board.json
+
+. /usr/share/libubox/jshn.sh
+
+json_select_array() {
+	local _json_no_warning=1
+
+	json_select "$1"
+	[ $? = 0 ] && return
+
+	json_add_array "$1"
+	json_close_array
+
+	json_select "$1"
+}
+
+json_select_object() {
+	local _json_no_warning=1
+
+	json_select "$1"
+	[ $? = 0 ] && return
+
+	json_add_object "$1"
+	json_close_object
+
+	json_select "$1"
+}
+
+_ucidef_set_interface() {
+	local name="$1"
+	local iface="$2"
+
+	json_select_object "$name"
+	json_add_string ifname "${iface%%.*}"
+	[ "$iface" = "${iface%%.*}" ] || json_add_boolean create_vlan 1
+	json_select ..
+}
+
+ucidef_set_board_id() {
+	json_select_object model
+	json_add_string id "$1"
+	json_select ..
+}
+
+ucidef_set_model_name() {
+	json_select_object model
+	json_add_string name "$1"
+	json_select ..
+}
+
+ucidef_set_interface_loopback()
+{
+	# stub
+	local a="$1"
+}
+
+ucidef_set_interface_lan() {
+	local lan_if="$1"
+
+	json_select_object network
+	_ucidef_set_interface lan "$lan_if"
+	json_select ..
+}
+
+ucidef_set_interface_wan() {
+        local wan_if="$1"
+
+        json_select_object network
+        _ucidef_set_interface wan "$wan_if"
+        json_select ..
+}
+
+ucidef_set_interfaces_lan_wan() {
+	local lan_if="$1"
+	local wan_if="$2"
+
+	json_select_object network
+	_ucidef_set_interface lan "$lan_if"
+	_ucidef_set_interface wan "$wan_if"
+	json_select ..
+}
+
+ucidef_add_switch() {
+	local name="$1"
+	local reset="$2"
+	local enable="$3"
+
+	json_select_object switch
+
+	json_select_object "$name"
+	json_add_boolean enable "$enable"
+	json_add_boolean reset "$reset"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_add_switch_attr() {
+	local name="$1"
+	local key="$2"
+	local val="$3"
+
+	json_select_object switch
+	json_select_object "$name"
+
+	case "$val" in
+		[0-9]) json_add_int "$key" "$val" ;;
+		*) json_add_string "$key" "$val" ;;
+	esac
+
+	json_select ..
+	json_select ..
+}
+
+ucidef_add_switch_ports() {
+	local name="$1"; shift
+	local port num role dev idx tag
+
+	json_select_object switch
+	json_select_object "$name"
+	json_select_array ports
+
+	for port in "$@"; do
+		case "$port" in
+			[0-9]*@*)
+				num="${port%%@*}"
+				dev="${port##*@}"
+				tag=0
+				[ "${num%t}" != "$num" ] && {
+					num="${num%t}"
+					tag=1
+				}
+			;;
+			[0-9]*:*:[0-9]*)
+				num="${port%%:*}"
+				idx="${port##*:}"
+				role="${port#[0-9]*:}"; role="${role%:*}"
+			;;
+			[0-9]*:*)
+				num="${port%%:*}"
+				role="${port##*:}"
+			;;
+		esac
+
+		if [ -n "$num" ] && [ -n "$dev$role" ]; then
+			json_add_object
+			json_add_int num "$num"
+			[ -n "$dev" ] && json_add_string device "$dev"
+			[ -n "$tag" ] && json_add_boolean need_tag "$tag"
+			[ -n "$role" ] && json_add_string role "$role"
+			[ -n "$idx" ] && json_add_int index "$idx"
+			json_close_object
+		fi
+
+		unset num dev role idx tag
+	done
+
+	json_select ..
+	json_select ..
+	json_select ..
+}
+
+ucidef_add_switch_port_attr() {
+	local name="$1"
+	local port="$2"
+	local key="$3"
+	local val="$4"
+	local ports i num
+
+	json_select_object switch
+	json_select_object "$name"
+
+	json_get_keys ports ports
+	json_select_array ports
+
+	for i in $ports; do
+		json_select "$i"
+		json_get_var num num
+
+		if [ -n "$num" ] && [ $num -eq $port ]; then
+			json_select_object attr
+
+			case "$val" in
+				[0-9]) json_add_int "$key" "$val" ;;
+				*) json_add_string "$key" "$val" ;;
+			esac
+
+			json_select ..
+		fi
+
+		json_select ..
+	done
+
+	json_select ..
+	json_select ..
+	json_select ..
+}
+
+ucidef_set_interfaces_vlans_lan_wan() {
+	local lan_vlan="$1"
+	local wan_vlan="$2"
+
+	json_select_object network
+	json_select_object "lan"
+	json_add_int vlan_id $lan_vlan
+	json_select ..
+	json_select_object "wan"
+	json_add_int vlan_id $wan_vlan
+	json_select ..
+	json_select ..
+}
+
+ucidef_add_switch_vlan() {
+	local name="$1"
+	local vlan="$2"
+	local ports="$3"
+	local cpu_port=''
+
+	json_select_object network
+	json_select_object "lan"
+	json_get_var vlan_id
+	lan_vlan=$vlan_id
+	json_select ..
+	json_select_object "wan"
+	json_get_var vlan_id
+	wan_vlan=$vlan_id
+	json_select ..
+
+	case "$vlan" in
+	$lan_vlan)	vlan=lan;;
+	$wan_vlan)	vlan=wan;;
+	*)		vlan=vlan$vlan;;
+	esac
+	json_select ..
+
+	json_select_object switch
+	json_select_object "$name"
+	json_select_object vlans
+
+	json_add_array "$vlan"
+	for p in $ports; do
+		if [ ${p%t} != $p ]; then
+			cpu_port=$p
+		else
+			json_add_int "" $p
+		fi
+	done
+	json_close_array
+
+	json_select ..
+	[ -n "$cpu_port" ] && json_add_int cpu_port "$cpu_port"
+	json_select ..
+	json_select ..
+}
+
+ucidef_set_interface_macaddr() {
+	local network="$1"
+	local macaddr="$2"
+
+	json_select_object network
+
+	json_select "$network"
+	[ $? -eq 0 ] || {
+		json_select ..
+		return
+	}
+
+	json_add_string macaddr "$macaddr"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_netdev() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local dev="$4"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string name "$name"
+	json_add_string type netdev
+	json_add_string sysfs "$sysfs"
+	json_add_string device "$dev"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_usbdev() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local dev="$4"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string name "$name"
+	json_add_string type usb
+	json_add_string sysfs "$sysfs"
+	json_add_string device "$dev"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_wlan() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local trigger="$4"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string name "$name"
+	json_add_string type trigger
+	json_add_string sysfs "$sysfs"
+	json_add_string trigger "$trigger"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_switch() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local trigger="$4"
+	local port_mask="$5"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string name "$name"
+	json_add_string type switch
+	json_add_string sysfs "$sysfs"
+	json_add_string trigger "$trigger"
+	json_add_string port_mask "$port_mask"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_default() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local default="$4"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string name "$name"
+	json_add_string sysfs "$sysfs"
+	json_add_string default "$default"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_gpio() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local gpio="$4"
+	local inverted="$5"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string type gpio
+	json_add_string name "$name"
+	json_add_string sysfs "$sysfs"
+	json_add_string trigger "$trigger"
+	json_add_int gpio "$gpio"
+	json_add_boolean inverted "$inverted"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_led_rssi() {
+	local cfg="led_$1"
+	local name="$2"
+	local sysfs="$3"
+	local iface="$4"
+	local minq="$5"
+	local maxq="$6"
+	local offset="$7"
+	local factor="$8"
+
+	json_select_object led
+
+	json_select_object "$1"
+	json_add_string type rssi
+	json_add_string name "$name"
+	json_add_string iface "$iface"
+	json_add_string sysfs "$sysfs"
+	json_add_string minq "$minq"
+	json_add_string maxq "$maxq"
+	json_add_string offset "$offset"
+	json_add_string factor "$factor"
+	json_select ..
+
+	json_select ..
+}
+
+ucidef_set_rssimon() {
+	local dev="$1"
+	local refresh="$2"
+	local threshold="$3"
+
+	json_select_object rssimon
+
+	json_select_object "$dev"
+	[ -n "$refresh" ] && json_add_int refresh "$refresh"
+	[ -n "$threshold" ] && json_add_int threshold "$threshold"
+	json_select ..
+
+	json_select ..
+
+}
+
+board_config_update() {
+	json_init
+	[ -f ${CFG} ] && json_load "$(cat ${CFG})"
+}
+
+board_config_flush() {
+	json_dump -i > /tmp/.board.json
+	mv /tmp/.board.json ${CFG}
+}
--- a/target/linux/ar71xx/base-files/etc/board.d/01_leds
+++ b/target/linux/ar71xx/base-files/etc/board.d/01_leds
@@ -3,7 +3,7 @@
 # Copyright (C) 2011 OpenWrt.org
 #
 
-. /lib/functions/uci-defaults.sh
+. /lib/functions/uci-defaults-new.sh
 . /lib/ar71xx.sh
 
 board_config_update
--- a/target/linux/ar71xx/base-files/etc/board.d/02_network
+++ b/target/linux/ar71xx/base-files/etc/board.d/02_network
@@ -4,7 +4,7 @@
 #
 
 . /lib/functions/system.sh
-. /lib/functions/uci-defaults.sh
+. /lib/functions/uci-defaults-new.sh
 . /lib/ar71xx.sh
 
 board_config_update
--- a/target/linux/ar71xx/base-files/etc/board.d/03_gpio_switches
+++ b/target/linux/ar71xx/base-files/etc/board.d/03_gpio_switches
@@ -3,7 +3,7 @@
 # Copyright (C) 2015 OpenWrt.org
 #
 
-. /lib/functions/uci-defaults.sh
+. /lib/functions/uci-defaults-new.sh
 . /lib/ar71xx.sh
 
 board_config_update
--- a/package/base-files/files/bin/config_generate
+++ b/package/base-files/files/bin/config_generate
@@ -18,178 +18,244 @@ generate_static_network() {
 		set network.globals='globals'
 		set network.globals.ula_prefix='auto'
 	EOF
-
-	if json_is_a dsl object; then
-		json_select dsl
-			if json_is_a atmbridge object; then
-				json_select atmbridge
-					local vpi vci encaps payload
-					json_get_vars vpi vci encaps payload
-					uci -q batch <<-EOF
-						delete network.atm
-						set network.atm='atm-bridge'
-						set network.atm.vpi='$vpi'
-						set network.atm.vci='$vci'
-						set network.atm.encaps='$encaps'
-						set network.atm.payload='$payload'
-					EOF
-				json_select ..
-			fi
-
-			if json_is_a modem object; then
-				json_select modem
-					local type annex firmware tone xfer_mode
-					json_get_vars type annex firmware tone xfer_mode
-					uci -q batch <<-EOF
-						delete network.dsl
-						set network.dsl='dsl'
-						set network.dsl.annex='$annex'
-						set network.dsl.firmware='$firmware'
-						set network.dsl.tone='$tone'
-						set network.dsl.xfer_mode='$xfer_mode'
-					EOF
-				json_select ..
-			fi
-		json_select ..
-	fi
 }
 
-addr_offset=2
+next_vlan=3
 generate_network() {
-	local ifname macaddr protocol type
+	local vlan
 
 	json_select network
-		json_select "$1"
-			json_get_vars ifname macaddr protocol
-		json_select ..
+	json_select "$1"
+	json_get_vars ifname create_vlan macaddr vlan_id
+	json_select ..
 	json_select ..
 
 	[ -n "$ifname" ] || return
 
-	# force bridge for multi-interface devices (and lan)
-	case "$1:$ifname" in
-		*\ * | lan:*) type="bridge" ;;
-	esac
+	if [ "${create_vlan:-0}" -eq 1 ]; then
+		case "$1" in
+			lan) [ -n "$vlan_id" ] && vlan=$vlan_id || vlan=1;;
+			wan) [ -n "$vlan_id" ] && vlan=$vlan_id || vlan=2;;
+			*)
+				vlan=$next_vlan
+				next_vlan=$((next_vlan + 1))
+			;;
+		esac
+	fi
+
+	[ -n "$vlan" ] && ifname=${ifname}.${vlan}
 
 	uci -q batch <<-EOF
 		delete network.$1
 		set network.$1='interface'
-		set network.$1.type='$type'
 		set network.$1.ifname='$ifname'
 		set network.$1.proto='none'
+		set network.$1.macaddr='$macaddr'
 	EOF
 
-	[ -n "$macaddr" ] && uci -q batch <<-EOF
-		delete network.$1_dev
-		set network.$1_dev='device'
-		set network.$1_dev.name='$ifname'
-		set network.$1_dev.macaddr='$macaddr'
-	EOF
-
-	case "$protocol" in
-		static)
-			local ipaddr
-			case "$1" in
-				lan) ipaddr="192.168.1.1" ;;
-				*) ipaddr="192.168.$((addr_offset++)).1" ;;
-			esac
-
+	case "$1" in
+		lan)
 			uci -q batch <<-EOF
+				set network.$1.type='bridge'
 				set network.$1.proto='static'
-				set network.$1.ipaddr='$ipaddr'
+				set network.$1.ipaddr='192.168.1.1'
 				set network.$1.netmask='255.255.255.0'
 				set network.$1.ip6assign='60'
 			EOF
 		;;
 
-		dhcp)
-			# fixup IPv6 slave interface if parent is a bridge
-			[ "$type" = "bridge" ] && ifname="br-$1"
-
+		wan)
 			uci -q batch <<-EOF
 				set network.$1.proto='dhcp'
-				delete network.${1}6
-				set network.${1}6='interface'
-				set network.${1}6.ifname='$ifname'
-				set network.${1}6.proto='dhcpv6'
+				delete network.wan6
+				set network.wan6='interface'
+				set network.wan6.ifname='$ifname'
+				set network.wan6.proto='dhcpv6'
 			EOF
 		;;
 
-		pppoe)
-			# fixup IPv6 slave interface
-			ifname="pppoe-$1"
-
+		*)
 			uci -q batch <<-EOF
-				set network.$1.proto='pppoe'
-				set network.$1.username='username'
-				set network.$1.password='password'
-				set network.$1.ipv6='auto'
-				delete network.${1}6
-				set network.${1}6='interface'
-				set network.${1}6.ifname='$ifname'
-				set network.${1}6.proto='dhcpv6'
+				set network.$1.force_link=1
 			EOF
 		;;
 	esac
 }
 
-generate_switch_vlans_ports() {
-	local switch="$1"
-	local port ports role roles num attr val
-
-	#
-	# autogenerate vlans
-	#
-
-	json_get_keys roles roles
-	json_select roles
-
-	for role in $roles; do
-		json_select "$role"
-			json_get_vars ports
-		json_select ..
-
-		uci -q batch <<-EOF
-			add network switch_vlan
-			set network.@switch_vlan[-1].device='$switch'
-			set network.@switch_vlan[-1].vlan='$role'
-			set network.@switch_vlan[-1].ports='$ports'
-		EOF
-	done
+generate_switch_vlan() {
+	local device="$1"
+	local vlan="$2"
+	local cpu_port="$3"
+
+	case "$vlan" in
+		lan) vlan=1;;
+		wan) vlan=2;;
+		*) vlan="${vlan##vlan}";;
+	esac
 
+	json_select vlans
+	json_select "$2"
+	json_get_values ports
+	json_select ..
 	json_select ..
 
+	if [ $((vlan)) -gt 127 ]; then
+		vid=$vlan
+		vlan=$next_vlan
+		next_vlan=$((next_vlan + 1))
+	else
+		vid=$vlan
+	fi
+	uci -q batch <<-EOF
+		add network switch_vlan
+		set network.@switch_vlan[-1].device='$device'
+		set network.@switch_vlan[-1].vlan='$vlan'
+		set network.@switch_vlan[-1].vid='$vid'
+		set network.@switch_vlan[-1].ports='$ports ${cpu_port}t'
+	EOF
+}
 
-	#
-	# write port specific settings
-	#
+calculate_switch_vlans() {
+	local switch="$1"
+	local ports port attr val prev_role
+	local num device role index need_tag
+	local cpu0 cpu1 cpu2 cpu3
+	local dev0 dev1 dev2 dev3
+	local tag0 tag1 tag2 tag3
+	local role0 role1 role2 role3
+	local n_cpu=0  n_vlan=0 vlan_off=-1
+	local vlan_ports cpu_port
 
 	json_get_keys ports ports
+
 	json_select ports
 
+	# gather all cpu ports and count vlans
 	for port in $ports; do
 		json_select "$port"
-			json_get_vars num
+		json_get_vars num device role need_tag
+
+		if json_is_a attr object; then
+			json_get_keys attr attr
+			json_select attr
+
+			uci -q batch <<-EOF
+				add network switch_port
+				set network.@switch_port[-1].device='$switch'
+				set network.@switch_port[-1].port=$num
+			EOF
+
+			for attr in $attr; do
+				json_get_var val "$attr"
+				uci -q set network.@switch_port[-1].$attr="$val"
+			done
+
+			json_select ..
+		fi
+
+		json_select ..
+
+		if [ -n "$num" ] && [ -n "$device" ]; then
+			export "cpu$n_cpu=$num"
+			export "dev$n_cpu=$device"
+			export "tag$n_cpu=${need_tag:-0}"
+			n_cpu=$((n_cpu + 1))
+		elif [ -n "$num" ] && [ -n "$role" ] && [ "$role" != "$prev_role" ]; then
+			export "role$n_vlan=$role"
+			n_vlan=$((n_vlan + 1))
+			prev_role="$role"
+		fi
+	done
+
+	unset prev_role
+
+	# autogenerate vlans
+	for port in $ports ""; do
+		if [ -n "$port" ]; then
+			json_select "$port"
+			json_get_vars num device role
+			json_select ..
+		else
+			num="-"; role="-"
+		fi
+
+		if [ -n "$num" ] && [ -n "$role" ]; then
+			if [ "$role" != "$prev_role" ]; then
+				if [ -n "$vlan_ports" ]; then
+					let cpu_port="cpu$((vlan_off % n_cpu))"
+					let need_tag="tag$((vlan_off % n_cpu))"
+					[ $n_vlan -gt $n_cpu -o $need_tag -eq 1 ] && cpu_port="${cpu_port}t"
 
-			if json_is_a attr object; then
-				json_get_keys attr attr
-				json_select attr
 					uci -q batch <<-EOF
-						add network switch_port
-						set network.@switch_port[-1].device='$switch'
-						set network.@switch_port[-1].port=$num
+						add network switch_vlan
+						set network.@switch_vlan[-1].device='$switch'
+						set network.@switch_vlan[-1].vlan='$((vlan_off + 1))'
+						set network.@switch_vlan[-1].ports='$vlan_ports $cpu_port'
 					EOF
+				fi
 
-					for attr in $attr; do
-						json_get_var val "$attr"
-						uci -q set network.@switch_port[-1].$attr="$val"
-					done
-				json_select ..
+				vlan_off=$((vlan_off + 1))
+				vlan_ports="$num"
+				prev_role="$role"
+			else
+				vlan_ports="$vlan_ports $num"
 			fi
-		json_select ..
+
+		fi
 	done
 
 	json_select ..
+
+	# autogenerate interfaces
+	vlan_off=0; while [ $vlan_off -lt $n_vlan ]; do
+		eval role="\$role$((vlan_off))"
+		eval device="\$dev$((vlan_off % n_cpu))"
+		let need_tag="tag$((vlan_off++ % n_cpu))"
+		[ $n_vlan -gt $n_cpu -o $need_tag -eq 1 ] && device="$device.$vlan_off"
+
+		# quirk: append ifnames for subsequent switches
+		case "$switch" in switch[1-9])
+			local prev_devs="$(uci -q get "network.$role.ifname")"
+			if echo "$prev_devs" | grep -wq "$device"; then
+				device="$prev_devs"
+			else
+				device="$prev_devs $device"
+			fi
+		;; esac
+
+		uci -q batch <<-EOF
+			set network.$role='interface'
+			set network.$role.ifname='$device'
+		EOF
+
+		case $role in
+			lan)
+				uci -q batch <<-EOF
+					set network.lan.type='bridge'
+					set network.lan.proto='static'
+					set network.lan.ipaddr='192.168.1.1'
+					set network.lan.netmask='255.255.255.0'
+					set network.lan.ip6assign='60'
+				EOF
+			;;
+
+			wan)
+				uci -q batch <<-EOF
+					set network.wan.proto='dhcp'
+					set network.wan6='interface'
+					set network.wan6.ifname='$device'
+					set network.wan6.proto='dhcpv6'
+				EOF
+			;;
+
+			*)
+				uci -q batch <<-EOF
+					set network.$role.force_link='1'
+					set network.$role.proto='none'
+				EOF
+			;;
+		esac
+	done
 }
 
 generate_switch() {
@@ -208,7 +274,12 @@ generate_switch() {
 		set network.@switch[-1].blinkrate='$blinkrate'
 	EOF
 
-	generate_switch_vlans_ports "$1"
+	if [ -n "$cpu_port" ]; then
+		json_get_keys vlans vlans
+		for vlan in $vlans; do generate_switch_vlan $1 $vlan $cpu_port; done
+	elif json_is_a ports array; then
+		calculate_switch_vlans $1
+	fi
 
 	json_select ..
 	json_select ..
@@ -263,11 +334,11 @@ generate_led() {
 		;;
 
 		netdev)
-			local device mode
-			json_get_vars device mode
+			local device
+			json_get_vars device
 			uci -q batch <<-EOF
 				set system.$cfg.trigger='netdev'
-				set system.$cfg.mode='$mode'
+				set system.$cfg.mode='link tx rx'
 				set system.$cfg.dev='$device'
 			EOF
 		;;
@@ -296,21 +367,10 @@ generate_led() {
 		;;
 
 		switch)
-			local port_mask speed_mask
-			json_get_vars port_mask speed_mask
+			local port_mask
+			json_get_vars port_mask
 			uci -q batch <<-EOF
 				set system.$cfg.port_mask='$port_mask'
-				set system.$cfg.speed_mask='$speed_mask'
-			EOF
-		;;
-
-		timer|oneshot)
-			local delayon delayoff
-			json_get_vars delayon delayoff
-			uci -q batch <<-EOF
-				set system.$cfg.trigger='$type'
-				set system.$cfg.delayon='$delayon'
-				set system.$cfg.delayoff='$delayoff'
 			EOF
 		;;
 	esac
@@ -319,24 +379,6 @@ generate_led() {
 	json_select ..
 }
 
-generate_gpioswitch() {
-	local cfg="$1"
-
-	json_select gpioswitch
-		json_select "$cfg"
-			local name pin default
-			json_get_vars name pin default
-			uci -q batch <<-EOF
-				delete system.$cfg
-				set system.$cfg='gpio_switch'
-				set system.$cfg.name='$name'
-				set system.$cfg.gpio_pin='$pin'
-				set system.$cfg.default='$default'
-			EOF
-		json_select ..
-	json_select ..
-}
-
 json_init
 json_load "$(cat ${CFG})"
 
@@ -351,9 +393,6 @@ for key in $keys; do generate_switch $ke
 json_get_keys keys rssimon
 for key in $keys; do generate_rssimon $key; done
 
-json_get_keys keys gpioswitch
-for key in $keys; do generate_gpioswitch $key; done
-
 json_get_keys keys led
 for key in $keys; do generate_led $key; done
 
