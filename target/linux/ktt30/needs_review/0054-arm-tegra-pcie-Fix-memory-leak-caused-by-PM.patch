From 48e806aa171752c95700cf805944cc567d754d78 Mon Sep 17 00:00:00 2001
From: Valentine Barshak <vbarshak@dev.rtsoft.ru>
Date: Wed, 10 Apr 2013 19:46:37 +0400
Subject: [PATCH 054/127] arm: tegra: pcie: Fix memory leak caused by PM

This moves MSI IRQ registration and msi_base allocation
to tegra_pcie_get_resource(), which is called once,
instead of registering the MSI IRQ and allocating
msi_base each time MSI is initialized, which is
done when the PCI driver wakes up from suspend.

Signed-off-by: Valentine Barshak <vbarshak@dev.rtsoft.ru>
---
 arch/arm/mach-tegra/pcie.c |   50 ++++++++++++++++++++++++++-----------------
 1 files changed, 30 insertions(+), 20 deletions(-)

diff --git a/arch/arm/mach-tegra/pcie.c b/arch/arm/mach-tegra/pcie.c
index 7f9d70f..94198c0 100644
--- a/arch/arm/mach-tegra/pcie.c
+++ b/arch/arm/mach-tegra/pcie.c
@@ -322,6 +322,7 @@ struct tegra_pcie_info {
 	void __iomem		*reg_clk_base;
 	void __iomem		*regs;
 	struct resource		*res_mmio;
+	u32			msi_aligned;
 	int			power_rails_enabled;
 	int			pcie_power_enabled;
 	struct work_struct 	hotplug_detect;
@@ -1150,9 +1151,12 @@ static void tegra_pcie_clocks_put(void)
 		clk_put(tegra_pcie.pcie_xclk);
 }
 
+static irqreturn_t tegra_pcie_msi_isr(int irq, void *arg);
+
 static int tegra_pcie_get_resources(void)
 {
 	int err;
+	u32 msi_base, msi_aligned;
 
 	tegra_pcie.power_rails_enabled = 0;
 	tegra_pcie.pcie_power_enabled = 0;
@@ -1175,6 +1179,27 @@ static int tegra_pcie_get_resources(void)
 	}
 	set_irq_flags(INT_PCIE_INTR, IRQF_VALID);
 
+	/* enables MSI interrupts.  */
+	err = request_irq(INT_PCIE_MSI, tegra_pcie_msi_isr,
+			IRQF_SHARED, "PCIe-MSI", &tegra_pcie);
+	if (err) {
+		pr_err("PCIE: Failed to register MSI IRQ %d\n", err);
+		goto err_msi_irq;
+	}
+
+	/* FIXME do this better! should be based on PAGE_SIZE */
+	msi_base = __get_free_pages(GFP_KERNEL, 3);
+	if (!msi_base) {
+		err = -ENOMEM;
+		pr_err("PCIE: Failed to allocate MSI base\n");
+		goto err_msi_base;
+	}
+
+	msi_aligned = ((msi_base + ((1<<12) - 1)) & ~((1<<12) - 1));
+	msi_aligned = virt_to_phys((void *)msi_aligned);
+
+	tegra_pcie.msi_aligned = msi_aligned;
+
 #ifdef CONFIG_PM
 	tegra_pcie.pm_nb.notifier_call = tegra_pcie_pm_handler;
 	tegra_pcie.pm_nb.priority = 0;
@@ -1183,6 +1208,10 @@ static int tegra_pcie_get_resources(void)
 
 	return 0;
 
+err_msi_base:
+	free_irq(INT_PCIE_MSI, &tegra_pcie);
+err_msi_irq:
+	free_irq(INT_PCIE_INTR, &tegra_pcie);
 err_pwr_on:
 	tegra_pcie_power_off();
 err_clk_get:
@@ -1622,8 +1651,7 @@ static bool tegra_pcie_enable_msi(void)
 {
 	bool retval = false;
 	u32 reg;
-	u32 msi_base = 0;
-	u32 msi_aligned = 0;
+	u32 msi_aligned = tegra_pcie.msi_aligned;
 
 	/* this only happens once. */
 	if (msi_enable) {
@@ -1631,21 +1659,7 @@ static bool tegra_pcie_enable_msi(void)
 		goto exit;
 	}
 	msi_map_init();
-
-	/* enables MSI interrupts.  */
-	if (request_irq(INT_PCIE_MSI, tegra_pcie_msi_isr,
-		IRQF_SHARED, "PCIe-MSI",
-		tegra_pcie_msi_isr)) {
-			pr_err("%s: Cannot register IRQ %u\n",
-				__func__, INT_PCIE_MSI);
-			goto exit;
-	}
 	/* setup AFI/FPCI range */
-	/* FIXME do this better! should be based on PAGE_SIZE */
-	msi_base = __get_free_pages(GFP_KERNEL, 3);
-	msi_aligned = ((msi_base + ((1<<12) - 1)) & ~((1<<12) - 1));
-	msi_aligned = virt_to_phys((void *)msi_aligned);
-
 #ifdef CONFIG_ARCH_TEGRA_2x_SOC
 	afi_writel(msi_aligned, AFI_MSI_FPCI_BAR_ST);
 #else
@@ -1676,10 +1690,6 @@ static bool tegra_pcie_enable_msi(void)
 	msi_enable = true;
 	retval = true;
 exit:
-	if (!retval) {
-		if (msi_base)
-			free_pages(msi_base, 3);
-	}
 	return retval;
 }
 
-- 
1.7.4.4

