From 7dc6d19a966740333496366edaba363562c0ac02 Mon Sep 17 00:00:00 2001
From: Maxim Yu. Osipov <mosipov@dev.rtsoft.ru>
Date: Wed, 29 May 2013 13:39:09 +0200
Subject: [PATCH 118/127] drivers: hwmon: tps6591x-hwmon.c: Intrusion
 detection support

Implemented scheme of intrusion detection described
in Documentation/hwmon/sysfs-interface.

Signed-off-by: Maxim Yu. Osipov <mosipov@dev.rtsoft.ru>
Signed-off-by: Valentine Barshak <vbarshak@dev.rtsoft.ru>
---
 drivers/hwmon/Kconfig          |    6 +
 drivers/hwmon/Makefile         |    1 +
 drivers/hwmon/tps6591x-hwmon.c |  207 ++++++++++++++++++++++++++++++++++++++++
 include/linux/mfd/tps6591x.h   |    6 +
 4 files changed, 220 insertions(+), 0 deletions(-)
 create mode 100644 drivers/hwmon/tps6591x-hwmon.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index e24962b..3233949 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1370,6 +1370,12 @@ config SENSORS_INA230
 	  Support for the TI INA230 power monitor sensor.
 	  (also works for TI INA226)
 
+config SENSORS_TPS6591X
+	tristate "Texas Instruments TPS6591X intrusion detection sensor driver"
+	depends on MFD_TPS6591X
+	help
+	  Support for the TI TPS6591X intrusion monitor sensor.
+
 
 if ACPI
 
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index e0dc2f7..e8bb0c0 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -127,6 +127,7 @@ obj-$(CONFIG_SENSORS_WM831X)	+= wm831x-hwmon.o
 obj-$(CONFIG_SENSORS_WM8350)	+= wm8350-hwmon.o
 obj-$(CONFIG_SENSORS_INA219)	+= ina219.o
 obj-$(CONFIG_SENSORS_INA230)	+= ina230.o
+obj-$(CONFIG_SENSORS_TPS6591X)	+= tps6591x-hwmon.o
 CFLAGS_tegra-tsensor.o		 = -Werror
 obj-$(CONFIG_SENSORS_TEGRA_TSENSOR) += tegra-tsensor.o
 
diff --git a/drivers/hwmon/tps6591x-hwmon.c b/drivers/hwmon/tps6591x-hwmon.c
new file mode 100644
index 0000000..099bffe
--- /dev/null
+++ b/drivers/hwmon/tps6591x-hwmon.c
@@ -0,0 +1,207 @@
+/*
+ * drivers/hwmon/tps6591x-hwmon.c
+ *
+ * TPS6591x intrusion detection driver
+ *
+ * Copyright (c) 2013, RTSoft
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mfd/tps6591x.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+
+#define DRIVER_NAME "tps6591x-hwmon"
+
+#define TPS6591X_INT_STS2		0x52
+#define TPS6591X_INT_STS3		0x54
+
+struct tps6591x_hwmon {
+	struct device *hwmon_dev;
+	unsigned char status_reg;
+	unsigned char mask_pos;
+};
+
+static ssize_t show_case_open(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct tps6591x_hwmon *hwmon = dev_get_drvdata(dev);
+	uint8_t val;
+	int ret;
+
+	ret = tps6591x_read(dev->parent, hwmon->status_reg, &val);
+	if (ret < 0) {
+		dev_err(dev->parent,
+				"failed to read 0x%x\n", hwmon->status_reg);
+		return ret;
+	}
+
+	return sprintf(buf, "%u\n", (val & hwmon->mask_pos) ? 1 : 0);
+}
+
+
+static ssize_t store_case_open_clear(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct tps6591x_hwmon *hwmon = dev_get_drvdata(dev);
+	unsigned long val;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &val);
+
+	if (ret < 0)
+		return ret;
+
+	if (val != 0)
+		return -EINVAL;
+
+	/* Reset the state */
+	ret = tps6591x_write(dev->parent, hwmon->status_reg, hwmon->mask_pos);
+	if (ret < 0) {
+		dev_err(dev->parent,
+				"failed to write 0x%x\n", hwmon->status_reg);
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t show_name(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "tps6591x\n");
+}
+
+static SENSOR_DEVICE_ATTR(intrusion0_alarm, S_IWUSR | S_IRUGO,
+			show_case_open, store_case_open_clear, 0);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, 0);
+
+static struct attribute *tps6591x_hwmon_attrs[] = {
+	&sensor_dev_attr_intrusion0_alarm.dev_attr.attr,
+	&sensor_dev_attr_name.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group tps6591x_hwmon_attr_group = {
+	.attrs = tps6591x_hwmon_attrs,
+};
+
+static int __devinit tps6591x_hwmon_probe(struct platform_device *pdev)
+{
+	struct tps6591x_hwmon_platform_data *pdata = pdev->dev.platform_data;
+	struct device *dev = &pdev->dev;
+	struct tps6591x_hwmon *hwmon;
+	int err;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform_data specified\n");
+		return -EINVAL;
+	}
+
+	hwmon = kzalloc(sizeof(struct tps6591x_hwmon), GFP_KERNEL);
+
+	if (!hwmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hwmon);
+
+	if (pdata->gpio_num < TPS6591X_GPIO_GP4) {
+		hwmon->status_reg = TPS6591X_INT_STS2;
+
+		if (pdata->edge_type & IRQF_TRIGGER_RISING)
+			hwmon->mask_pos |= 1 << (pdata->gpio_num * 2);
+
+		if (pdata->edge_type & IRQF_TRIGGER_FALLING)
+			hwmon->mask_pos |= 1 << (pdata->gpio_num * 2 + 1);
+	} else if (pdata->gpio_num < TPS6591X_GPIO_GP6) {
+		hwmon->status_reg = TPS6591X_INT_STS3;
+
+		if (pdata->edge_type & IRQF_TRIGGER_RISING)
+			hwmon->mask_pos |= 1 << ((pdata->gpio_num * 2) % 8);
+
+		if (pdata->edge_type & IRQF_TRIGGER_FALLING)
+			hwmon->mask_pos |=
+					1 << (((pdata->gpio_num * 2) % 8) + 1);
+	} else {
+		err = -EINVAL;
+		dev_err(&pdev->dev, "wrong gpio num specified\n");
+		goto exit_remove;
+	}
+
+	err = sysfs_create_group(&dev->kobj, &tps6591x_hwmon_attr_group);
+
+	if (err)
+		goto exit_remove;
+
+	hwmon->hwmon_dev = hwmon_device_register(dev);
+
+	if ((IS_ERR(hwmon->hwmon_dev))) {
+		err = PTR_ERR(hwmon->hwmon_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+exit_remove:
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+	return err;
+}
+
+static int __devexit tps6591x_hwmon_remove(struct platform_device *pdev)
+{
+	struct tps6591x_hwmon *hwmon = dev_get_drvdata(&pdev->dev);
+
+	hwmon_device_unregister(hwmon->hwmon_dev);
+
+	/* Remove sysfs files */
+	sysfs_remove_group(&pdev->dev.kobj, &tps6591x_hwmon_attr_group);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+	return 0;
+}
+
+
+static struct platform_driver tps6591x_hwmon_driver = {
+	.driver = {
+		.name   = DRIVER_NAME,
+		.owner  = THIS_MODULE,
+	},
+	.probe          = tps6591x_hwmon_probe,
+	.remove         = tps6591x_hwmon_remove,
+};
+
+
+static int __init tps6591x_hwmon_init(void)
+{
+	return platform_driver_register(&tps6591x_hwmon_driver);
+}
+module_init(tps6591x_hwmon_init);
+
+static void __exit tps6591x_hwmon_exit(void)
+{
+	platform_driver_unregister(&tps6591x_hwmon_driver);
+}
+module_exit(tps6591x_hwmon_exit);
+
+MODULE_DESCRIPTION("TPS6591x intrusion detection driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("RTSoft");
+MODULE_ALIAS("platform:" DRIVER_NAME);
diff --git a/include/linux/mfd/tps6591x.h b/include/linux/mfd/tps6591x.h
index d0d829f..25a12f3 100644
--- a/include/linux/mfd/tps6591x.h
+++ b/include/linux/mfd/tps6591x.h
@@ -76,6 +76,12 @@ struct tps6591x_rtc_platform_data {
 	struct rtc_time time;
 };
 
+struct tps6591x_hwmon_platform_data {
+	unsigned char gpio_num;
+	/* The same as the IRQF_* bits in linux/interrupt.h */
+	unsigned long edge_type;
+};
+
 struct tps6591x_sleep_keepon_data {
 	/* set 1 to maintain the following on sleep mode */
 	unsigned therm_keepon:1;	/* themal monitoring */
-- 
1.7.4.4

