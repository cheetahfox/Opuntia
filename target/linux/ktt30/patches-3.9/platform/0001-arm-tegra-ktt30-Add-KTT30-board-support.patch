From 2caf709243b565251327a404ea634b925da17bea Mon Sep 17 00:00:00 2001
From: Valentine Barshak <vbarshak@dev.rtsoft.ru>
Date: Sun, 17 Mar 2013 01:08:24 +0400
Subject: [PATCH 001/127] arm: tegra: ktt30: Add KTT30 board support

This adds KTT30 base support, based on the
previous work for r16 by:
Dmitry Artamonov <dartamonov@dev.rtsoft.ru>

With modifications and clean-up by:
Mariusz Ptak <mariusz.ptak@kontron.pl> and
Valentine Barshak <vbarshak@dev.rtsoft.ru>

Modified ktt30_audio_wm8903_pdata.
Added tegra_io_dpd_init() and ktt30_dt_board_compat[]
to arch/arm/mach-tegra/board-ktt30.c.
Also added basic device tree:
arch/arm/boot/dts/tegra30-ktt30.dts

Signed-off-by: Valentine Barshak <vbarshak@dev.rtsoft.ru>
---
 arch/arm/boot/dts/tegra30-ktt30.dts        |    8 +
 arch/arm/mach-tegra/Kconfig                |    7 +
 arch/arm/mach-tegra/Makefile               |    9 +
 arch/arm/mach-tegra/board-ktt30-memory.c   |  996 ++++++++++++++++++++++++++++
 arch/arm/mach-tegra/board-ktt30-panel.c    |  787 ++++++++++++++++++++++
 arch/arm/mach-tegra/board-ktt30-pinmux.c   |  550 +++++++++++++++
 arch/arm/mach-tegra/board-ktt30-power.c    |  659 ++++++++++++++++++
 arch/arm/mach-tegra/board-ktt30-powermon.c |   48 ++
 arch/arm/mach-tegra/board-ktt30-sdhci.c    |  150 +++++
 arch/arm/mach-tegra/board-ktt30-sensors.c  |  121 ++++
 arch/arm/mach-tegra/board-ktt30.c          |  831 +++++++++++++++++++++++
 arch/arm/mach-tegra/board-ktt30.h          |   85 +++
 arch/arm/tools/mach-types                  |    1 +
 13 files changed, 4252 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/boot/dts/tegra30-ktt30.dts
 create mode 100644 arch/arm/mach-tegra/board-ktt30-memory.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-panel.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-pinmux.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-power.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-powermon.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-sdhci.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30-sensors.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30.c
 create mode 100644 arch/arm/mach-tegra/board-ktt30.h

--- /dev/null
+++ b/arch/arm/boot/dts/tegra30-ktt30.dts
@@ -0,0 +1,8 @@
+/dts-v1/;
+
+/include/ "tegra30.dtsi"
+
+/ {
+	model = "Kontron Tegra30 KTT30 evaluation board";
+	compatible = "kontron,ktt30", "nvidia,tegra30";
+};
--- a/arch/arm/mach-tegra/Kconfig
+++ b/arch/arm/mach-tegra/Kconfig
@@ -44,6 +44,13 @@ config ARCH_TEGRA_3x_SOC
 	  Support for NVIDIA Tegra T30 processor family, based on the
 	  ARM CortexA9MP CPU and the ARM PL310 L2 cache controller
 
+config MACH_KTT30
+	bool "Kontron KTT30 board"
+	depends on ARCH_TEGRA_3x_SOC
+	select MACH_HAS_SND_SOC_TEGRA_WM8903 if SND_SOC
+	help
+	  Support for Kontron KTT30 mITX platform
+
 config TEGRA_PCI
 	bool "PCI Express support"
 	depends on ARCH_TEGRA_2x_SOC
--- a/arch/arm/mach-tegra/Makefile
+++ b/arch/arm/mach-tegra/Makefile
@@ -38,3 +38,12 @@ obj-$(CONFIG_ARCH_TEGRA_3x_SOC)		+= boar
 obj-$(CONFIG_ARCH_TEGRA_2x_SOC)		+= board-harmony-pcie.o
 
 obj-$(CONFIG_ARCH_TEGRA_2x_SOC)		+= board-paz00.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-panel.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-pinmux.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-power.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-sdhci.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-sensors.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-memory.o
+obj-${CONFIG_MACH_KTT30}		+= board-ktt30-powermon.o
+
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-memory.c
@@ -0,0 +1,996 @@
+/*
+ * Copyright (C) 2011 NVIDIA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include "board.h"
+#include "board-ktt30.h"
+#include "tegra3_emc.h"
+#include "fuse.h"
+
+
+static const struct tegra_emc_table ktt30_emc_tables_k4b4g0846b_hyk0[] = {
+	{
+		0x32,       /* Rev 3.2 */
+		25500,      /* SDRAM frequency */
+		{
+			0x00000001, /* EMC_RC */
+			0x00000006, /* EMC_RFC */
+			0x00000000, /* EMC_RAS */
+			0x00000000, /* EMC_RP */
+			0x00000002, /* EMC_R2W */
+			0x0000000a, /* EMC_W2R */
+			0x00000005, /* EMC_R2P */
+			0x0000000b, /* EMC_W2P */
+			0x00000000, /* EMC_RD_RCD */
+			0x00000000, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000005, /* EMC_WDV */
+			0x00000005, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x00000009, /* EMC_QSAFE */
+			0x0000000b, /* EMC_RDV */
+			0x000000c0, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x00000030, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000002, /* EMC_PDEX2WR */
+			0x00000002, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000007, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x00000007, /* EMC_TXSR */
+			0x00000007, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x00000001, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x000000c7, /* EMC_TREFBW */
+			0x00000006, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00004288, /* EMC_FBIO_CFG5 */
+			0x007800a4, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x000fc000, /* EMC_DLL_XFORM_DQS0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS3 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS4 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS5 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS6 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800211c, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f108, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x08000168, /* EMC_XM2QUSEPADCTRL */
+			0x08000000, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00000000, /* EMC_ZCAL_INTERVAL */
+			0x00000040, /* EMC_ZCAL_WAIT_CNT */
+			0x000c000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x80000287, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00020001, /* MC_EMEM_ARB_CFG */
+			0xc0000010, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000000, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000001, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000001, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06020102, /* MC_EMEM_ARB_DA_TURNS */
+			0x000a0402, /* MC_EMEM_ARB_DA_COVERS */
+			0x75830303, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xe8000000, /* EMC_FBIO_SPARE */
+			0xff00ff00, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80001221, /* Mode Register 0 */
+		0x80100003, /* Mode Register 1 */
+		0x80200008, /* Mode Register 2 */
+		0x00000001, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		51000,      /* SDRAM frequency */
+		{
+			0x00000002, /* EMC_RC */
+			0x0000000d, /* EMC_RFC */
+			0x00000001, /* EMC_RAS */
+			0x00000000, /* EMC_RP */
+			0x00000002, /* EMC_R2W */
+			0x0000000a, /* EMC_W2R */
+			0x00000005, /* EMC_R2P */
+			0x0000000b, /* EMC_W2P */
+			0x00000000, /* EMC_RD_RCD */
+			0x00000000, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000005, /* EMC_WDV */
+			0x00000005, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x00000009, /* EMC_QSAFE */
+			0x0000000b, /* EMC_RDV */
+			0x00000181, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x00000060, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000002, /* EMC_PDEX2WR */
+			0x00000002, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000007, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x0000000e, /* EMC_TXSR */
+			0x0000000e, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x00000002, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x0000018e, /* EMC_TREFBW */
+			0x00000006, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00004288, /* EMC_FBIO_CFG5 */
+			0x007800a4, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x000fc000, /* EMC_DLL_XFORM_DQS0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS3 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS4 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS5 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS6 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800211c, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f108, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x08000168, /* EMC_XM2QUSEPADCTRL */
+			0x08000000, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00000000, /* EMC_ZCAL_INTERVAL */
+			0x00000040, /* EMC_ZCAL_WAIT_CNT */
+			0x000c000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x8000040b, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00010001, /* MC_EMEM_ARB_CFG */
+			0xc0000010, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000000, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000001, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000001, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06020102, /* MC_EMEM_ARB_DA_TURNS */
+			0x000a0402, /* MC_EMEM_ARB_DA_COVERS */
+			0x74630303, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xe8000000, /* EMC_FBIO_SPARE */
+			0xff00ff00, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80001221, /* Mode Register 0 */
+		0x80100003, /* Mode Register 1 */
+		0x80200008, /* Mode Register 2 */
+		0x00000001, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		102000,     /* SDRAM frequency */
+		{
+			0x00000004, /* EMC_RC */
+			0x0000001a, /* EMC_RFC */
+			0x00000003, /* EMC_RAS */
+			0x00000001, /* EMC_RP */
+			0x00000002, /* EMC_R2W */
+			0x0000000a, /* EMC_W2R */
+			0x00000005, /* EMC_R2P */
+			0x0000000b, /* EMC_W2P */
+			0x00000001, /* EMC_RD_RCD */
+			0x00000001, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000005, /* EMC_WDV */
+			0x00000005, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x00000009, /* EMC_QSAFE */
+			0x0000000b, /* EMC_RDV */
+			0x00000303, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x000000c0, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000002, /* EMC_PDEX2WR */
+			0x00000002, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000007, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x0000001c, /* EMC_TXSR */
+			0x0000001c, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x00000004, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x0000031c, /* EMC_TREFBW */
+			0x00000006, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00004288, /* EMC_FBIO_CFG5 */
+			0x007800a4, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x000fc000, /* EMC_DLL_XFORM_DQS0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS3 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS4 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS5 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS6 */
+			0x000fc000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ0 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ1 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ2 */
+			0x000fc000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800211c, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f108, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x08000168, /* EMC_XM2QUSEPADCTRL */
+			0x08000000, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00000000, /* EMC_ZCAL_INTERVAL */
+			0x00000040, /* EMC_ZCAL_WAIT_CNT */
+			0x000c000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x80000713, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00000001, /* MC_EMEM_ARB_CFG */
+			0xc0000018, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000003, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000000, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000001, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000001, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06020102, /* MC_EMEM_ARB_DA_TURNS */
+			0x000a0403, /* MC_EMEM_ARB_DA_COVERS */
+			0x73c30504, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xe8000000, /* EMC_FBIO_SPARE */
+			0xff00ff00, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80001221, /* Mode Register 0 */
+		0x80100003, /* Mode Register 1 */
+		0x80200008, /* Mode Register 2 */
+		0x00000001, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		204000,     /* SDRAM frequency */
+		{
+			0x00000009, /* EMC_RC */
+			0x00000035, /* EMC_RFC */
+			0x00000007, /* EMC_RAS */
+			0x00000002, /* EMC_RP */
+			0x00000002, /* EMC_R2W */
+			0x0000000a, /* EMC_W2R */
+			0x00000005, /* EMC_R2P */
+			0x0000000b, /* EMC_W2P */
+			0x00000002, /* EMC_RD_RCD */
+			0x00000002, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000005, /* EMC_WDV */
+			0x00000005, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x00000009, /* EMC_QSAFE */
+			0x0000000b, /* EMC_RDV */
+			0x00000607, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x00000181, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000002, /* EMC_PDEX2WR */
+			0x00000002, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000007, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x00000038, /* EMC_TXSR */
+			0x00000038, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x00000007, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x00000638, /* EMC_TREFBW */
+			0x00000006, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00004288, /* EMC_FBIO_CFG5 */
+			0x004400a4, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x00080000, /* EMC_DLL_XFORM_DQS0 */
+			0x00080000, /* EMC_DLL_XFORM_DQS1 */
+			0x00080000, /* EMC_DLL_XFORM_DQS2 */
+			0x00080000, /* EMC_DLL_XFORM_DQS3 */
+			0x00080000, /* EMC_DLL_XFORM_DQS4 */
+			0x00080000, /* EMC_DLL_XFORM_DQS5 */
+			0x00080000, /* EMC_DLL_XFORM_DQS6 */
+			0x00080000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x00080000, /* EMC_DLL_XFORM_DQ0 */
+			0x00080000, /* EMC_DLL_XFORM_DQ1 */
+			0x00080000, /* EMC_DLL_XFORM_DQ2 */
+			0x00080000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800211c, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f108, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x08000168, /* EMC_XM2QUSEPADCTRL */
+			0x08000000, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00020000, /* EMC_ZCAL_INTERVAL */
+			0x00000100, /* EMC_ZCAL_WAIT_CNT */
+			0x000c000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x80000d22, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00000003, /* MC_EMEM_ARB_CFG */
+			0xc0000025, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000005, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000003, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000001, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06020102, /* MC_EMEM_ARB_DA_TURNS */
+			0x000a0405, /* MC_EMEM_ARB_DA_COVERS */
+			0x73840a06, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xe8000000, /* EMC_FBIO_SPARE */
+			0xff00ff00, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80001221, /* Mode Register 0 */
+		0x80100003, /* Mode Register 1 */
+		0x80200008, /* Mode Register 2 */
+		0x00000001, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		375000,     /* SDRAM frequency */
+		{
+			0x00000011, /* EMC_RC */
+			0x00000060, /* EMC_RFC */
+			0x0000000c, /* EMC_RAS */
+			0x00000004, /* EMC_RP */
+			0x00000003, /* EMC_R2W */
+			0x00000008, /* EMC_W2R */
+			0x00000002, /* EMC_R2P */
+			0x0000000a, /* EMC_W2P */
+			0x00000004, /* EMC_RD_RCD */
+			0x00000004, /* EMC_WR_RCD */
+			0x00000002, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000004, /* EMC_WDV */
+			0x00000006, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x0000000a, /* EMC_QSAFE */
+			0x0000000d, /* EMC_RDV */
+			0x00000b2d, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x000002cb, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000001, /* EMC_PDEX2WR */
+			0x00000008, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000007, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x00000066, /* EMC_TXSR */
+			0x00000200, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x0000000c, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x00000b6d, /* EMC_TREFBW */
+			0x00000000, /* EMC_QUSE_EXTRA */
+			0x00000006, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00007088, /* EMC_FBIO_CFG5 */
+			0x00200084, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x00014000, /* EMC_DLL_XFORM_DQS0 */
+			0x00014000, /* EMC_DLL_XFORM_DQS1 */
+			0x00014000, /* EMC_DLL_XFORM_DQS2 */
+			0x00014000, /* EMC_DLL_XFORM_DQS3 */
+			0x00014000, /* EMC_DLL_XFORM_DQS4 */
+			0x00014000, /* EMC_DLL_XFORM_DQS5 */
+			0x00014000, /* EMC_DLL_XFORM_DQS6 */
+			0x00014000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x00020000, /* EMC_DLL_XFORM_DQ0 */
+			0x00020000, /* EMC_DLL_XFORM_DQ1 */
+			0x00020000, /* EMC_DLL_XFORM_DQ2 */
+			0x00020000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800013d, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f508, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x080001e8, /* EMC_XM2QUSEPADCTRL */
+			0x08000021, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00020000, /* EMC_ZCAL_INTERVAL */
+			0x00000100, /* EMC_ZCAL_WAIT_CNT */
+			0x015f000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x8000174b, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00000005, /* MC_EMEM_ARB_CFG */
+			0x80000044, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000009, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000005, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000005, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000002, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000003, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06030202, /* MC_EMEM_ARB_DA_TURNS */
+			0x000d0709, /* MC_EMEM_ARB_DA_COVERS */
+			0x7086110a, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0x58000000, /* EMC_FBIO_SPARE */
+			0xff00ff88, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000000, /* EMC_CFG.PERIODIC_QRST */
+		0x80000521, /* Mode Register 0 */
+		0x80100002, /* Mode Register 1 */
+		0x80200000, /* Mode Register 2 */
+		0x00000000, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		400000,     /* SDRAM frequency */
+		{
+			0x00000012, /* EMC_RC */
+			0x00000066, /* EMC_RFC */
+			0x0000000c, /* EMC_RAS */
+			0x00000004, /* EMC_RP */
+			0x00000003, /* EMC_R2W */
+			0x00000008, /* EMC_W2R */
+			0x00000002, /* EMC_R2P */
+			0x0000000a, /* EMC_W2P */
+			0x00000004, /* EMC_RD_RCD */
+			0x00000004, /* EMC_WR_RCD */
+			0x00000002, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000004, /* EMC_WDV */
+			0x00000006, /* EMC_QUSE */
+			0x00000004, /* EMC_QRST */
+			0x0000000a, /* EMC_QSAFE */
+			0x0000000c, /* EMC_RDV */
+			0x00000bf0, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x000002fc, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000001, /* EMC_PDEX2WR */
+			0x00000008, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x00000008, /* EMC_AR2PDEN */
+			0x0000000f, /* EMC_RW2PDEN */
+			0x0000006c, /* EMC_TXSR */
+			0x00000200, /* EMC_TXSRDLL */
+			0x00000004, /* EMC_TCKE */
+			0x0000000c, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000004, /* EMC_TCLKSTABLE */
+			0x00000005, /* EMC_TCLKSTOP */
+			0x00000c30, /* EMC_TREFBW */
+			0x00000000, /* EMC_QUSE_EXTRA */
+			0x00000006, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00007088, /* EMC_FBIO_CFG5 */
+			0x001d0084, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x00034000, /* EMC_DLL_XFORM_DQS0 */
+			0x00034000, /* EMC_DLL_XFORM_DQS1 */
+			0x00034000, /* EMC_DLL_XFORM_DQS2 */
+			0x00034000, /* EMC_DLL_XFORM_DQS3 */
+			0x00034000, /* EMC_DLL_XFORM_DQS4 */
+			0x00034000, /* EMC_DLL_XFORM_DQS5 */
+			0x00034000, /* EMC_DLL_XFORM_DQS6 */
+			0x00034000, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x00040000, /* EMC_DLL_XFORM_DQ0 */
+			0x00040000, /* EMC_DLL_XFORM_DQ1 */
+			0x00040000, /* EMC_DLL_XFORM_DQ2 */
+			0x00040000, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0800013d, /* EMC_XM2DQSPADCTRL2 */
+			0x00000000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f508, /* EMC_XM2COMPPADCTRL */
+			0x05057404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000007, /* EMC_XM2VTTGENPADCTRL2 */
+			0x080001e8, /* EMC_XM2QUSEPADCTRL */
+			0x08000021, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00020000, /* EMC_ZCAL_INTERVAL */
+			0x00000100, /* EMC_ZCAL_WAIT_CNT */
+			0x0158000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x800018c8, /* EMC_DYN_SELF_REF_CONTROL */
+			0x00000006, /* MC_EMEM_ARB_CFG */
+			0x80000048, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000009, /* MC_EMEM_ARB_TIMING_RC */
+			0x00000005, /* MC_EMEM_ARB_TIMING_RAS */
+			0x00000005, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000001, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x00000008, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000002, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000003, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000006, /* MC_EMEM_ARB_TIMING_W2R */
+			0x06030202, /* MC_EMEM_ARB_DA_TURNS */
+			0x000d0709, /* MC_EMEM_ARB_DA_COVERS */
+			0x7566120a, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xe8000000, /* EMC_FBIO_SPARE */
+			0xff00ff89, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000000, /* EMC_CFG.PERIODIC_QRST */
+		0x80000521, /* Mode Register 0 */
+		0x80100002, /* Mode Register 1 */
+		0x80200000, /* Mode Register 2 */
+		0x00000000, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		750000,     /* SDRAM frequency */
+		{
+			0x00000023, /* EMC_RC */
+			0x000000c1, /* EMC_RFC */
+			0x00000019, /* EMC_RAS */
+			0x00000009, /* EMC_RP */
+			0x00000005, /* EMC_R2W */
+			0x0000000d, /* EMC_W2R */
+			0x00000004, /* EMC_R2P */
+			0x00000013, /* EMC_W2P */
+			0x00000009, /* EMC_RD_RCD */
+			0x00000009, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000007, /* EMC_WDV */
+			0x0000000b, /* EMC_QUSE */
+			0x00000009, /* EMC_QRST */
+			0x0000000c, /* EMC_QSAFE */
+			0x00000011, /* EMC_RDV */
+			0x0000169a, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x000005a6, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000003, /* EMC_PDEX2WR */
+			0x00000010, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x0000000e, /* EMC_AR2PDEN */
+			0x00000018, /* EMC_RW2PDEN */
+			0x000000cb, /* EMC_TXSR */
+			0x00000200, /* EMC_TXSRDLL */
+			0x00000005, /* EMC_TCKE */
+			0x00000017, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000007, /* EMC_TCLKSTABLE */
+			0x00000008, /* EMC_TCLKSTOP */
+			0x000016da, /* EMC_TREFBW */
+			0x0000000c, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00005088, /* EMC_FBIO_CFG5 */
+			0xf0080191, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x00000008, /* EMC_DLL_XFORM_DQS0 */
+			0x00000008, /* EMC_DLL_XFORM_DQS1 */
+			0x00000008, /* EMC_DLL_XFORM_DQS2 */
+			0x00000008, /* EMC_DLL_XFORM_DQS3 */
+			0x00000008, /* EMC_DLL_XFORM_DQS4 */
+			0x00000008, /* EMC_DLL_XFORM_DQS5 */
+			0x00000008, /* EMC_DLL_XFORM_DQS6 */
+			0x00000008, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x0000000c, /* EMC_DLL_XFORM_DQ0 */
+			0x0000000c, /* EMC_DLL_XFORM_DQ1 */
+			0x0000000c, /* EMC_DLL_XFORM_DQ2 */
+			0x0000000c, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0600013d, /* EMC_XM2DQSPADCTRL2 */
+			0x22220000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f501, /* EMC_XM2COMPPADCTRL */
+			0x07077404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000000, /* EMC_XM2VTTGENPADCTRL2 */
+			0x080001e8, /* EMC_XM2QUSEPADCTRL */
+			0x08000021, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00020000, /* EMC_ZCAL_INTERVAL */
+			0x00000100, /* EMC_ZCAL_WAIT_CNT */
+			0x00fd000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x80002d93, /* EMC_DYN_SELF_REF_CONTROL */
+			0x0000000b, /* MC_EMEM_ARB_CFG */
+			0x80000087, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000004, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000005, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000012, /* MC_EMEM_ARB_TIMING_RC */
+			0x0000000c, /* MC_EMEM_ARB_TIMING_RAS */
+			0x0000000b, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000003, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x0000000c, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000002, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000004, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000008, /* MC_EMEM_ARB_TIMING_W2R */
+			0x08040202, /* MC_EMEM_ARB_DA_TURNS */
+			0x00160d12, /* MC_EMEM_ARB_DA_COVERS */
+			0x710c2213, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xf8000000, /* EMC_FBIO_SPARE */
+			0xff00ff49, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80000d71, /* Mode Register 0 */
+		0x80100002, /* Mode Register 1 */
+		0x80200018, /* Mode Register 2 */
+		0x00000000, /* EMC_CFG.DYN_SELF_REF */
+	},
+	{
+		0x32,       /* Rev 3.2 */
+		800000,     /* SDRAM frequency */
+		{
+			0x00000025, /* EMC_RC */
+			0x000000ce, /* EMC_RFC */
+			0x0000001a, /* EMC_RAS */
+			0x00000009, /* EMC_RP */
+			0x00000005, /* EMC_R2W */
+			0x0000000d, /* EMC_W2R */
+			0x00000004, /* EMC_R2P */
+			0x00000013, /* EMC_W2P */
+			0x00000009, /* EMC_RD_RCD */
+			0x00000009, /* EMC_WR_RCD */
+			0x00000003, /* EMC_RRD */
+			0x00000001, /* EMC_REXT */
+			0x00000000, /* EMC_WEXT */
+			0x00000007, /* EMC_WDV */
+			0x0000000b, /* EMC_QUSE */
+			0x00000009, /* EMC_QRST */
+			0x0000000b, /* EMC_QSAFE */
+			0x00000011, /* EMC_RDV */
+			0x00001820, /* EMC_REFRESH */
+			0x00000000, /* EMC_BURST_REFRESH_NUM */
+			0x00000608, /* EMC_PRE_REFRESH_REQ_CNT */
+			0x00000003, /* EMC_PDEX2WR */
+			0x00000012, /* EMC_PDEX2RD */
+			0x00000001, /* EMC_PCHG2PDEN */
+			0x00000000, /* EMC_ACT2PDEN */
+			0x0000000f, /* EMC_AR2PDEN */
+			0x00000018, /* EMC_RW2PDEN */
+			0x000000d8, /* EMC_TXSR */
+			0x00000200, /* EMC_TXSRDLL */
+			0x00000005, /* EMC_TCKE */
+			0x00000018, /* EMC_TFAW */
+			0x00000000, /* EMC_TRPAB */
+			0x00000007, /* EMC_TCLKSTABLE */
+			0x00000008, /* EMC_TCLKSTOP */
+			0x00001860, /* EMC_TREFBW */
+			0x0000000c, /* EMC_QUSE_EXTRA */
+			0x00000004, /* EMC_FBIO_CFG6 */
+			0x00000000, /* EMC_ODT_WRITE */
+			0x00000000, /* EMC_ODT_READ */
+			0x00005088, /* EMC_FBIO_CFG5 */
+			0xf0070191, /* EMC_CFG_DIG_DLL */
+			0x00008000, /* EMC_CFG_DIG_DLL_PERIOD */
+			0x0000800a, /* EMC_DLL_XFORM_DQS0 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS1 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS2 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS3 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS4 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS5 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS6 */
+			0x0000800a, /* EMC_DLL_XFORM_DQS7 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE0 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE1 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE2 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE3 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE4 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE5 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE6 */
+			0x00000000, /* EMC_DLL_XFORM_QUSE7 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS0 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS1 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS2 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS3 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS4 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS5 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS6 */
+			0x00000000, /* EMC_DLI_TRIM_TXDQS7 */
+			0x0000000a, /* EMC_DLL_XFORM_DQ0 */
+			0x0000000a, /* EMC_DLL_XFORM_DQ1 */
+			0x0000000a, /* EMC_DLL_XFORM_DQ2 */
+			0x0000000a, /* EMC_DLL_XFORM_DQ3 */
+			0x000002a0, /* EMC_XM2CMDPADCTRL */
+			0x0600013d, /* EMC_XM2DQSPADCTRL2 */
+			0x22220000, /* EMC_XM2DQPADCTRL2 */
+			0x77fff884, /* EMC_XM2CLKPADCTRL */
+			0x01f1f501, /* EMC_XM2COMPPADCTRL */
+			0x07077404, /* EMC_XM2VTTGENPADCTRL */
+			0x54000000, /* EMC_XM2VTTGENPADCTRL2 */
+			0x080001e8, /* EMC_XM2QUSEPADCTRL */
+			0x09000021, /* EMC_XM2DQSPADCTRL3 */
+			0x00000802, /* EMC_CTT_TERM_CTRL */
+			0x00020000, /* EMC_ZCAL_INTERVAL */
+			0x00000100, /* EMC_ZCAL_WAIT_CNT */
+			0x00f0000c, /* EMC_MRS_WAIT_CNT */
+			0xa0f10000, /* EMC_AUTO_CAL_CONFIG */
+			0x00000000, /* EMC_CTT */
+			0x00000000, /* EMC_CTT_DURATION */
+			0x8000308c, /* EMC_DYN_SELF_REF_CONTROL */
+			0x0000000c, /* MC_EMEM_ARB_CFG */
+			0x80000090, /* MC_EMEM_ARB_OUTSTANDING_REQ */
+			0x00000004, /* MC_EMEM_ARB_TIMING_RCD */
+			0x00000005, /* MC_EMEM_ARB_TIMING_RP */
+			0x00000013, /* MC_EMEM_ARB_TIMING_RC */
+			0x0000000c, /* MC_EMEM_ARB_TIMING_RAS */
+			0x0000000b, /* MC_EMEM_ARB_TIMING_FAW */
+			0x00000002, /* MC_EMEM_ARB_TIMING_RRD */
+			0x00000003, /* MC_EMEM_ARB_TIMING_RAP2PRE */
+			0x0000000c, /* MC_EMEM_ARB_TIMING_WAP2PRE */
+			0x00000002, /* MC_EMEM_ARB_TIMING_R2R */
+			0x00000002, /* MC_EMEM_ARB_TIMING_W2W */
+			0x00000004, /* MC_EMEM_ARB_TIMING_R2W */
+			0x00000008, /* MC_EMEM_ARB_TIMING_W2R */
+			0x08040202, /* MC_EMEM_ARB_DA_TURNS */
+			0x00160d13, /* MC_EMEM_ARB_DA_COVERS */
+			0x734c2414, /* MC_EMEM_ARB_MISC0 */
+			0x001f0000, /* MC_EMEM_ARB_RING1_THROTTLE */
+			0xf8000000, /* EMC_FBIO_SPARE */
+			0xff00ff49, /* EMC_CFG_RSV */
+		},
+		0x00000040, /* EMC_ZCAL_WAIT_CNT after clock change */
+		0x001fffff, /* EMC_AUTO_CAL_INTERVAL */
+		0x00000001, /* EMC_CFG.PERIODIC_QRST */
+		0x80000d71, /* Mode Register 0 */
+		0x80100002, /* Mode Register 1 */
+		0x80200018, /* Mode Register 2 */
+		0x00000000, /* EMC_CFG.DYN_SELF_REF */
+	},
+};
+
+int ktt30_emc_init(void)
+{
+	tegra_init_emc(ktt30_emc_tables_k4b4g0846b_hyk0,
+			ARRAY_SIZE(ktt30_emc_tables_k4b4g0846b_hyk0));
+	return 0;
+}
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-panel.c
@@ -0,0 +1,787 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30-panel.c
+ *
+ * Copyright (c) 2010-2012, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/delay.h>
+#include <linux/ion.h>
+#include <linux/tegra_ion.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/resource.h>
+#include <asm/mach-types.h>
+#include <linux/platform_device.h>
+#include <linux/earlysuspend.h>
+#include <linux/pwm_backlight.h>
+#include <asm/atomic.h>
+#include <linux/nvhost.h>
+#include <linux/nvmap.h>
+#include <mach/irqs.h>
+#include <mach/iomap.h>
+#include <mach/dc.h>
+#include <mach/fb.h>
+#include <mach/smmu.h>
+
+#include "board.h"
+#include "board-ktt30.h"
+#include "devices.h"
+#include "gpio-names.h"
+#include "tegra3_host1x_devices.h"
+
+/* ktt30 default display board pins */
+#define ktt30_lvds_shutdown		TEGRA_GPIO_PK3
+
+/* common pins( backlight ) for all display boards */
+#define ktt30_bl_enb			TEGRA_GPIO_PH2
+#define ktt30_bl_pwm			TEGRA_GPIO_PH0
+#define ktt30_hdmi_hpd			TEGRA_GPIO_PN7
+
+#ifdef CONFIG_TEGRA_DC
+static struct regulator *ktt30_hdmi_reg = NULL;
+static struct regulator *ktt30_hdmi_pll = NULL;
+static struct regulator *ktt30_hdmi_vddio = NULL;
+
+static struct regulator *ktt30_lvds_reg = NULL;
+static struct regulator *ktt30_lvds_vdd_bl = NULL;
+static struct regulator *ktt30_lvds_vdd_panel = NULL;
+#endif
+
+static atomic_t sd_brightness = ATOMIC_INIT(255);
+
+static tegra_dc_bl_output ktt30_bl_output_measured = {
+	0, 1, 2, 3, 4, 5, 6, 7,
+	8, 9, 10, 11, 12, 13, 14, 15,
+	16, 17, 18, 19, 20, 21, 22, 23,
+	24, 25, 26, 27, 28, 29, 30, 31,
+	32, 33, 34, 35, 36, 37, 38, 39,
+	40, 41, 42, 43, 44, 45, 46, 47,
+	48, 49, 49, 50, 51, 52, 53, 54,
+	55, 56, 57, 58, 59, 60, 61, 62,
+	63, 64, 65, 66, 67, 68, 69, 70,
+	70, 72, 73, 74, 75, 76, 77, 78,
+	79, 80, 81, 82, 83, 84, 85, 86,
+	87, 88, 89, 90, 91, 92, 93, 94,
+	95, 96, 97, 98, 99, 100, 101, 102,
+	103, 104, 105, 106, 107, 108, 110, 111,
+	112, 113, 114, 115, 116, 117, 118, 119,
+	120, 121, 122, 123, 124, 124, 125, 126,
+	127, 128, 129, 130, 131, 132, 133, 133,
+	134, 135, 136, 137, 138, 139, 140, 141,
+	142, 143, 144, 145, 146, 147, 148, 148,
+	149, 150, 151, 152, 153, 154, 155, 156,
+	157, 158, 159, 160, 161, 162, 163, 164,
+	165, 166, 167, 168, 169, 170, 171, 172,
+	173, 174, 175, 176, 177, 179, 180, 181,
+	182, 184, 185, 186, 187, 188, 189, 190,
+	191, 192, 193, 194, 195, 196, 197, 198,
+	199, 200, 201, 202, 203, 204, 205, 206,
+	207, 208, 209, 211, 212, 213, 214, 215,
+	216, 217, 218, 219, 220, 221, 222, 223,
+	224, 225, 226, 227, 228, 229, 230, 231,
+	232, 233, 234, 235, 236, 237, 238, 239,
+	240, 241, 242, 243, 244, 245, 246, 247,
+	248, 249, 250, 251, 252, 253, 254, 255
+};
+
+static p_tegra_dc_bl_output bl_output = ktt30_bl_output_measured;
+
+static int ktt30_backlight_init(struct device *dev)
+{
+	int ret = 0;
+
+	if (WARN_ON(ARRAY_SIZE(ktt30_bl_output_measured) != 256))
+		pr_err("bl_output array does not have 256 elements\n");
+
+	ret = gpio_request(ktt30_bl_enb, "backlight_enb");
+	if (ret < 0)
+		return ret;
+
+	ret = gpio_direction_output(ktt30_bl_enb, 1);
+	if (ret < 0)
+		gpio_free(ktt30_bl_enb);
+
+	return ret;
+};
+
+static void ktt30_backlight_exit(struct device *dev)
+{
+	/* int ret; */
+	/*ret = gpio_request(ktt30_bl_enb, "backlight_enb");*/
+	gpio_set_value(ktt30_bl_enb, 0);
+	gpio_free(ktt30_bl_enb);
+}
+
+static int ktt30_backlight_notify(struct device *unused, int brightness)
+{
+	int cur_sd_brightness = atomic_read(&sd_brightness);
+
+	/* Set the backlight GPIO pin mode to 'backlight_enable' */
+	gpio_set_value(ktt30_bl_enb, !!brightness);
+
+	/* SD brightness is a percentage, 8-bit value. */
+	brightness = (brightness * cur_sd_brightness) / 255;
+
+	/* Apply any backlight response curve */
+	if (brightness > 255) {
+		pr_info("Error: Brightness > 255!\n");
+	} else {
+		brightness = bl_output[brightness];
+	}
+
+	return brightness;
+}
+
+static int ktt30_disp1_check_fb(struct device *dev, struct fb_info *info);
+
+static struct platform_pwm_backlight_data ktt30_backlight_data = {
+	.pwm_id		= 0,
+	.max_brightness	= 255,
+	.dft_brightness	= 224,
+	.pwm_period_ns	= 1000000,
+	.init		= ktt30_backlight_init,
+	.exit		= ktt30_backlight_exit,
+	.notify		= ktt30_backlight_notify,
+	/* Only toggle backlight on fb blank notifications for disp1 */
+	.check_fb	= ktt30_disp1_check_fb,
+};
+
+static struct platform_device ktt30_backlight_device = {
+	.name	= "pwm-backlight",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &ktt30_backlight_data,
+	},
+};
+
+#ifdef CONFIG_TEGRA_DC
+static int ktt30_panel_enable(void)
+{
+	if (ktt30_lvds_reg == NULL) {
+		ktt30_lvds_reg = regulator_get(NULL, "vdd_lvds");
+		if (WARN_ON(IS_ERR(ktt30_lvds_reg))) {
+			pr_err("%s: couldn't get regulator vdd_lvds: %ld\n",
+				__func__, PTR_ERR(ktt30_lvds_reg));
+			ktt30_lvds_reg = NULL;
+		} else {
+			regulator_enable(ktt30_lvds_reg);
+		}
+	}
+
+	if (ktt30_lvds_vdd_bl == NULL) {
+		ktt30_lvds_vdd_bl = regulator_get(NULL, "vdd_backlight");
+		if (WARN_ON(IS_ERR(ktt30_lvds_vdd_bl))) {
+			pr_err("%s: couldn't get regulator vdd_backlight: %ld\n",
+				__func__, PTR_ERR(ktt30_lvds_vdd_bl));
+			ktt30_lvds_vdd_bl = NULL;
+		} else {
+			regulator_enable(ktt30_lvds_vdd_bl);
+		}
+	}
+
+	if (ktt30_lvds_vdd_panel == NULL) {
+		ktt30_lvds_vdd_panel = regulator_get(NULL, "vdd_lcd_panel");
+		if (WARN_ON(IS_ERR(ktt30_lvds_vdd_panel))) {
+			pr_err("%s: couldn't get regulator vdd_lcd_panel: %ld\n",
+				__func__, PTR_ERR(ktt30_lvds_vdd_panel));
+			ktt30_lvds_vdd_panel = NULL;
+		} else {
+			regulator_enable(ktt30_lvds_vdd_panel);
+		}
+	}
+
+	gpio_set_value(ktt30_lvds_shutdown, 1);
+
+	return 0;
+}
+
+static int ktt30_panel_disable(void)
+{
+	if (ktt30_lvds_reg) {
+		regulator_disable(ktt30_lvds_reg);
+		regulator_put(ktt30_lvds_reg);
+		ktt30_lvds_reg = NULL;
+	}
+
+	if (ktt30_lvds_vdd_bl) {
+		regulator_disable(ktt30_lvds_vdd_bl);
+		regulator_put(ktt30_lvds_vdd_bl);
+		ktt30_lvds_vdd_bl = NULL;
+	}
+
+	if (ktt30_lvds_vdd_panel) {
+		regulator_disable(ktt30_lvds_vdd_panel);
+		regulator_put(ktt30_lvds_vdd_panel);
+		ktt30_lvds_vdd_panel = NULL;
+	}
+
+	gpio_set_value(ktt30_lvds_shutdown, 0);
+	return 0;
+}
+
+static int ktt30_hdmi_vddio_enable(void)
+{
+	int ret;
+	if (!ktt30_hdmi_vddio) {
+		ktt30_hdmi_vddio = regulator_get(NULL, "vdd_hdmi_con");
+		if (IS_ERR_OR_NULL(ktt30_hdmi_vddio)) {
+			ret = PTR_ERR(ktt30_hdmi_vddio);
+			pr_err("hdmi: couldn't get regulator vdd_hdmi_con\n");
+			ktt30_hdmi_vddio = NULL;
+			return ret;
+		}
+	}
+	ret = regulator_enable(ktt30_hdmi_vddio);
+	if (ret < 0) {
+		pr_err("hdmi: couldn't enable regulator vdd_hdmi_con\n");
+		regulator_put(ktt30_hdmi_vddio);
+		ktt30_hdmi_vddio = NULL;
+		return ret;
+	}
+	return ret;
+}
+
+static int ktt30_hdmi_vddio_disable(void)
+{
+	if (ktt30_hdmi_vddio) {
+		regulator_disable(ktt30_hdmi_vddio);
+		regulator_put(ktt30_hdmi_vddio);
+		ktt30_hdmi_vddio = NULL;
+	}
+	return 0;
+}
+
+static int ktt30_hdmi_enable(void)
+{
+	int ret;
+	if (!ktt30_hdmi_reg) {
+		ktt30_hdmi_reg = regulator_get(NULL, "avdd_hdmi");
+		if (IS_ERR_OR_NULL(ktt30_hdmi_reg)) {
+			pr_err("hdmi: couldn't get regulator avdd_hdmi\n");
+			ktt30_hdmi_reg = NULL;
+			return PTR_ERR(ktt30_hdmi_reg);
+		}
+	}
+	ret = regulator_enable(ktt30_hdmi_reg);
+	if (ret < 0) {
+		pr_err("hdmi: couldn't enable regulator avdd_hdmi\n");
+		return ret;
+	}
+	if (!ktt30_hdmi_pll) {
+		ktt30_hdmi_pll = regulator_get(NULL, "avdd_hdmi_pll");
+		if (IS_ERR_OR_NULL(ktt30_hdmi_pll)) {
+			pr_err("hdmi: couldn't get regulator avdd_hdmi_pll\n");
+			ktt30_hdmi_pll = NULL;
+			regulator_disable(ktt30_hdmi_reg);
+			regulator_put(ktt30_hdmi_reg);
+			ktt30_hdmi_reg = NULL;
+			return PTR_ERR(ktt30_hdmi_pll);
+		}
+	}
+	ret = regulator_enable(ktt30_hdmi_pll);
+	if (ret < 0) {
+		pr_err("hdmi: couldn't enable regulator avdd_hdmi_pll\n");
+		return ret;
+	}
+	return 0;
+}
+
+static int ktt30_hdmi_disable(void)
+{
+	if (ktt30_hdmi_reg) {
+		regulator_disable(ktt30_hdmi_reg);
+		regulator_put(ktt30_hdmi_reg);
+		ktt30_hdmi_reg = NULL;
+	}
+
+	if (ktt30_hdmi_pll) {
+		regulator_disable(ktt30_hdmi_pll);
+		regulator_put(ktt30_hdmi_pll);
+		ktt30_hdmi_pll = NULL;
+	}
+	return 0;
+}
+
+static struct resource ktt30_disp1_resources[] = {
+	{
+		.name	= "irq",
+		.start	= INT_DISPLAY_GENERAL,
+		.end	= INT_DISPLAY_GENERAL,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "regs",
+		.start	= TEGRA_DISPLAY_BASE,
+		.end	= TEGRA_DISPLAY_BASE + TEGRA_DISPLAY_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "fbmem",
+		.start	= 0,	/* Filled in by ktt30_panel_init() */
+		.end	= 0,	/* Filled in by ktt30_panel_init() */
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource ktt30_disp2_resources[] = {
+	{
+		.name	= "irq",
+		.start	= INT_DISPLAY_B_GENERAL,
+		.end	= INT_DISPLAY_B_GENERAL,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "regs",
+		.start	= TEGRA_DISPLAY2_BASE,
+		.end	= TEGRA_DISPLAY2_BASE + TEGRA_DISPLAY2_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "fbmem",
+		.flags	= IORESOURCE_MEM,
+		.start	= 0,	/* Filled in by ktt30_panel_init() */
+		.end	= 0,	/* Filled in by ktt30_panel_init() */
+	},
+	{
+		.name	= "hdmi_regs",
+		.start	= TEGRA_HDMI_BASE,
+		.end	= TEGRA_HDMI_BASE + TEGRA_HDMI_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct tegra_dc_mode ktt30_panel_modes[] = {
+	{
+		/* 1366x768@60Hz */
+		.pclk = 74180000,
+		.h_ref_to_sync = 1,
+		.v_ref_to_sync = 1,
+		.h_sync_width = 30,
+		.v_sync_width = 5,
+		.h_back_porch = 52,
+		.v_back_porch = 20,
+		.h_active = 1366,
+		.v_active = 768,
+		.h_front_porch = 64,
+		.v_front_porch = 25,
+	},
+	{
+		/* 1366x768@50Hz */
+		.pclk = 74180000,
+		.h_ref_to_sync = 1,
+		.v_ref_to_sync = 1,
+		.h_sync_width = 30,
+		.v_sync_width = 5,
+		.h_back_porch = 56,
+		.v_back_porch = 80,
+		.h_active = 1366,
+		.v_active = 768,
+		.h_front_porch = 64,
+		.v_front_porch = 125,
+	},
+	{
+		/* 1366x768@48 */
+		.pclk = 74180000,
+		.h_ref_to_sync = 1,
+		.v_ref_to_sync = 1,
+		.h_sync_width = 30,
+		.v_sync_width = 5,
+		.h_back_porch = 52,
+		.v_back_porch = 98,
+		.h_active = 1366,
+		.v_active = 768,
+		.h_front_porch = 64,
+		.v_front_porch = 152,
+	},
+};
+
+static struct tegra_dc_sd_settings ktt30_sd_settings = {
+	.enable = 1, /* enabled by default. */
+	.use_auto_pwm = false,
+	.hw_update_delay = 0,
+	.bin_width = -1,
+	.aggressiveness = 1,
+	.phase_in_adjustments = true,
+	.use_vid_luma = false,
+	/* Default video coefficients */
+	.coeff = {5, 9, 2},
+	.fc = {0, 0},
+	/* Immediate backlight changes */
+	.blp = {1024, 255},
+	/* Gammas: R: 2.2 G: 2.2 B: 2.2 */
+	/* Default BL TF */
+	.bltf = {
+			{
+				{57, 65, 74, 83},
+				{93, 103, 114, 126},
+				{138, 151, 165, 179},
+				{194, 209, 225, 242},
+			},
+			{
+				{58, 66, 75, 84},
+				{94, 105, 116, 127},
+				{140, 153, 166, 181},
+				{196, 211, 227, 244},
+			},
+			{
+				{60, 68, 77, 87},
+				{97, 107, 119, 130},
+				{143, 156, 170, 184},
+				{199, 215, 231, 248},
+			},
+			{
+				{64, 73, 82, 91},
+				{102, 113, 124, 137},
+				{149, 163, 177, 192},
+				{207, 223, 240, 255},
+			},
+		},
+	/* Default LUT */
+	.lut = {
+			{
+				{250, 250, 250},
+				{194, 194, 194},
+				{149, 149, 149},
+				{113, 113, 113},
+				{82, 82, 82},
+				{56, 56, 56},
+				{34, 34, 34},
+				{15, 15, 15},
+				{0, 0, 0},
+			},
+			{
+				{246, 246, 246},
+				{191, 191, 191},
+				{147, 147, 147},
+				{111, 111, 111},
+				{80, 80, 80},
+				{55, 55, 55},
+				{33, 33, 33},
+				{14, 14, 14},
+				{0, 0, 0},
+			},
+			{
+				{239, 239, 239},
+				{185, 185, 185},
+				{142, 142, 142},
+				{107, 107, 107},
+				{77, 77, 77},
+				{52, 52, 52},
+				{30, 30, 30},
+				{12, 12, 12},
+				{0, 0, 0},
+			},
+			{
+				{224, 224, 224},
+				{173, 173, 173},
+				{133, 133, 133},
+				{99, 99, 99},
+				{70, 70, 70},
+				{46, 46, 46},
+				{25, 25, 25},
+				{7, 7, 7},
+				{0, 0, 0},
+			},
+		},
+	.sd_brightness = &sd_brightness,
+	.bl_device = &ktt30_backlight_device,
+};
+
+static struct tegra_fb_data ktt30_fb_data = {
+	.win		= 0,
+	.xres		= 1366,
+	.yres		= 768,
+	.bits_per_pixel	= 32,
+	.flags		= TEGRA_FB_FLIP_ON_PROBE,
+};
+
+static struct tegra_fb_data ktt30_hdmi_fb_data = {
+	.win		= 0,
+	.xres		= 640,
+	.yres		= 480,
+	.bits_per_pixel	= 32,
+	.flags		= TEGRA_FB_FLIP_ON_PROBE,
+};
+
+static struct tegra_dc_out ktt30_disp2_out = {
+	.type		= TEGRA_DC_OUT_HDMI,
+	.flags		= TEGRA_DC_OUT_HOTPLUG_HIGH,
+	.parent_clk	= "pll_d2_out0",
+
+	.dcc_bus	= 3,
+	.hotplug_gpio	= ktt30_hdmi_hpd,
+
+	.max_pixclock	= KHZ2PICOS(148500),
+
+	.align		= TEGRA_DC_ALIGN_MSB,
+	.order		= TEGRA_DC_ORDER_RED_BLUE,
+
+	.enable		= ktt30_hdmi_enable,
+	.disable	= ktt30_hdmi_disable,
+
+	.postsuspend	= ktt30_hdmi_vddio_disable,
+	.hotplug_init	= ktt30_hdmi_vddio_enable,
+};
+
+static struct tegra_dc_platform_data ktt30_disp2_pdata = {
+	.flags		= TEGRA_DC_FLAG_ENABLED,
+	.default_out	= &ktt30_disp2_out,
+	.fb		= &ktt30_hdmi_fb_data,
+	.emc_clk_rate	= 300000000,
+};
+
+
+static struct tegra_dc_out ktt30_disp1_out = {
+	.align		= TEGRA_DC_ALIGN_MSB,
+	.order		= TEGRA_DC_ORDER_RED_BLUE,
+	.sd_settings	= &ktt30_sd_settings,
+	.parent_clk	= "pll_d_out0",
+	.parent_clk_backup = "pll_d2_out0",
+	.type		= TEGRA_DC_OUT_RGB,
+	.depth		= 18,
+	.dither		= TEGRA_DC_ORDERED_DITHER,
+	.modes		= ktt30_panel_modes,
+	.n_modes	= ARRAY_SIZE(ktt30_panel_modes),
+	.enable		= ktt30_panel_enable,
+	.disable	= ktt30_panel_disable,
+};
+
+static struct tegra_dc_platform_data ktt30_disp1_pdata = {
+	.flags		= TEGRA_DC_FLAG_ENABLED,
+	.default_out	= &ktt30_disp1_out,
+	.emc_clk_rate	= 300000000,
+	.fb		= &ktt30_fb_data,
+};
+
+static struct nvhost_device ktt30_disp1_device = {
+	.name		= "tegradc",
+	.id		= 0,
+	.resource	= ktt30_disp1_resources,
+	.num_resources	= ARRAY_SIZE(ktt30_disp1_resources),
+	.dev = {
+		.platform_data = &ktt30_disp1_pdata,
+	},
+};
+
+static int ktt30_disp1_check_fb(struct device *dev, struct fb_info *info)
+{
+	return info->device == &ktt30_disp1_device.dev;
+}
+
+static struct nvhost_device ktt30_disp2_device = {
+	.name		= "tegradc",
+	.id		= 1,
+	.resource	= ktt30_disp2_resources,
+	.num_resources	= ARRAY_SIZE(ktt30_disp2_resources),
+	.dev = {
+		.platform_data = &ktt30_disp2_pdata,
+	},
+};
+#else
+static int ktt30_disp1_check_fb(struct device *dev, struct fb_info *info)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_TEGRA_NVMAP)
+static struct nvmap_platform_carveout ktt30_carveouts[] = {
+	[0] = NVMAP_HEAP_CARVEOUT_IRAM_INIT,
+	[1] = {
+		.name		= "generic-0",
+		.usage_mask	= NVMAP_HEAP_CARVEOUT_GENERIC,
+		.base		= 0,	/* Filled in by ktt30_panel_init() */
+		.size		= 0,	/* Filled in by ktt30_panel_init() */
+		.buddy_size	= SZ_32K,
+	},
+};
+
+static struct nvmap_platform_data ktt30_nvmap_data = {
+	.carveouts	= ktt30_carveouts,
+	.nr_carveouts	= ARRAY_SIZE(ktt30_carveouts),
+};
+
+static struct platform_device ktt30_nvmap_device = {
+	.name	= "tegra-nvmap",
+	.id	= -1,
+	.dev	= {
+		.platform_data = &ktt30_nvmap_data,
+	},
+};
+#endif
+
+#if defined(CONFIG_ION_TEGRA)
+
+static struct platform_device tegra_iommu_device = {
+	.name = "tegra_iommu_device",
+	.id = -1,
+	.dev = {
+		.platform_data = (void *)((1 << HWGRP_COUNT) - 1),
+	},
+};
+
+static struct ion_platform_data tegra_ion_data = {
+	.nr = 4,
+	.heaps = {
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = TEGRA_ION_HEAP_CARVEOUT,
+			.name = "carveout",
+			.base = 0,
+			.size = 0,
+		},
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = TEGRA_ION_HEAP_IRAM,
+			.name = "iram",
+			.base = TEGRA_IRAM_BASE + TEGRA_RESET_HANDLER_SIZE,
+			.size = TEGRA_IRAM_SIZE - TEGRA_RESET_HANDLER_SIZE,
+		},
+		{
+			.type = ION_HEAP_TYPE_CARVEOUT,
+			.id = TEGRA_ION_HEAP_VPR,
+			.name = "vpr",
+			.base = 0,
+			.size = 0,
+		},
+		{
+			.type = ION_HEAP_TYPE_IOMMU,
+			.id = TEGRA_ION_HEAP_IOMMU,
+			.name = "iommu",
+			.base = TEGRA_SMMU_BASE,
+			.size = TEGRA_SMMU_SIZE,
+			.priv = &tegra_iommu_device.dev,
+		},
+	},
+};
+
+static struct platform_device tegra_ion_device = {
+	.name = "ion-tegra",
+	.id = -1,
+	.dev = {
+		.platform_data = &tegra_ion_data,
+	},
+};
+#endif
+
+static struct platform_device *ktt30_gfx_devices[] __initdata = {
+#if defined(CONFIG_TEGRA_NVMAP)
+	&ktt30_nvmap_device,
+#endif
+#if defined(CONFIG_ION_TEGRA)
+	&tegra_ion_device,
+#endif
+	&tegra_pwfm0_device,
+	&ktt30_backlight_device,
+};
+
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+/* put early_suspend/late_resume handlers here for the display in order
+ * to keep the code out of the display driver, keeping it closer to upstream
+ */
+struct early_suspend ktt30_panel_early_suspender;
+
+static void ktt30_panel_early_suspend(struct early_suspend *h)
+{
+	/* power down LCD, add use a black screen for HDMI */
+	if (num_registered_fb > 0)
+		fb_blank(registered_fb[0], FB_BLANK_POWERDOWN);
+	if (num_registered_fb > 1)
+		fb_blank(registered_fb[1], FB_BLANK_NORMAL);
+}
+
+static void ktt30_panel_late_resume(struct early_suspend *h)
+{
+	unsigned i;
+	for (i = 0; i < num_registered_fb; i++)
+		fb_blank(registered_fb[i], FB_BLANK_UNBLANK);
+}
+#endif
+
+
+int __init ktt30_panel_init(void)
+{
+	int err;
+	struct resource __maybe_unused *res;
+
+#if defined(CONFIG_TEGRA_NVMAP)
+	ktt30_carveouts[1].base = tegra_carveout_start;
+	ktt30_carveouts[1].size = tegra_carveout_size;
+#endif
+
+#if defined(CONFIG_ION_TEGRA)
+	tegra_ion_data.heaps[0].base = tegra_carveout_start;
+	tegra_ion_data.heaps[0].size = tegra_carveout_size;
+#endif
+
+#if defined(CONFIG_TEGRA_DC)
+	gpio_request(ktt30_lvds_shutdown, "lvds_shutdown");
+	gpio_direction_output(ktt30_lvds_shutdown, 1);
+#endif
+
+	gpio_request(ktt30_hdmi_hpd, "hdmi_hpd");
+	gpio_direction_input(ktt30_hdmi_hpd);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	ktt30_panel_early_suspender.suspend = ktt30_panel_early_suspend;
+	ktt30_panel_early_suspender.resume = ktt30_panel_late_resume;
+	ktt30_panel_early_suspender.level = EARLY_SUSPEND_LEVEL_DISABLE_FB;
+	register_early_suspend(&ktt30_panel_early_suspender);
+#endif
+
+#ifdef CONFIG_TEGRA_GRHOST
+	err = tegra3_register_host1x_devices();
+	if (err)
+		return err;
+#endif
+
+	err = platform_add_devices(ktt30_gfx_devices,
+				ARRAY_SIZE(ktt30_gfx_devices));
+
+#if defined(CONFIG_TEGRA_GRHOST) && defined(CONFIG_TEGRA_DC)
+	res = nvhost_get_resource_byname(&ktt30_disp1_device,
+					 IORESOURCE_MEM, "fbmem");
+	res->start = tegra_fb_start;
+	res->end = tegra_fb_start + tegra_fb_size - 1;
+
+	/* Copy the bootloader fb to the fb. */
+	tegra_move_framebuffer(tegra_fb_start, tegra_bootloader_fb_start,
+				min(tegra_fb_size, tegra_bootloader_fb_size));
+
+	if (!err)
+		err = nvhost_device_register(&ktt30_disp1_device);
+
+	res = nvhost_get_resource_byname(&ktt30_disp2_device,
+					 IORESOURCE_MEM, "fbmem");
+	res->start = tegra_fb2_start;
+	res->end = tegra_fb2_start + tegra_fb2_size - 1;
+
+	/* Copy the bootloader fb to the fb2. */
+	tegra_move_framebuffer(tegra_fb2_start, tegra_bootloader_fb_start,
+				min(tegra_fb2_size, tegra_bootloader_fb_size));
+
+	if (!err)
+		err = nvhost_device_register(&ktt30_disp2_device);
+#endif
+
+#if defined(CONFIG_TEGRA_GRHOST) && defined(CONFIG_TEGRA_NVAVP)
+	if (!err)
+		err = nvhost_device_register(&nvavp_device);
+#endif
+	return err;
+}
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-pinmux.c
@@ -0,0 +1,550 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30-pinmux.c
+ *
+ * Copyright (C) 2011-2012, NVIDIA Corporation
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <mach/pinmux.h>
+#include "board.h"
+#include "board-ktt30.h"
+#include "gpio-names.h"
+
+#define DEFAULT_DRIVE(_name)					\
+	{							\
+		.pingroup = TEGRA_DRIVE_PINGROUP_##_name,	\
+		.hsm = TEGRA_HSM_DISABLE,			\
+		.schmitt = TEGRA_SCHMITT_ENABLE,		\
+		.drive = TEGRA_DRIVE_DIV_1,			\
+		.pull_down = TEGRA_PULL_31,			\
+		.pull_up = TEGRA_PULL_31,			\
+		.slew_rising = TEGRA_SLEW_SLOWEST,		\
+		.slew_falling = TEGRA_SLEW_SLOWEST,		\
+	}
+/* Setting the drive strength of pins
+ * hsm: Enable High speed mode (ENABLE/DISABLE)
+ * Schimit: Enable/disable schimit (ENABLE/DISABLE)
+ * drive: low power mode (DIV_1, DIV_2, DIV_4, DIV_8)
+ * pulldn_drive - drive down (falling edge) - Driver Output Pull-Down drive
+ *                strength code. Value from 0 to 31.
+ * pullup_drive - drive up (rising edge)  - Driver Output Pull-Up drive
+ *                strength code. Value from 0 to 31.
+ * pulldn_slew -  Driver Output Pull-Up slew control code  - 2bit code
+ *                code 11 is least slewing of signal. code 00 is highest
+ *                slewing of the signal.
+ *                Value - FASTEST, FAST, SLOW, SLOWEST
+ * pullup_slew -  Driver Output Pull-Down slew control code -
+ *                code 11 is least slewing of signal. code 00 is highest
+ *                slewing of the signal.
+ *                Value - FASTEST, FAST, SLOW, SLOWEST
+ */
+#define SET_DRIVE(_name, _hsm, _schmitt, _drive, _pulldn_drive, _pullup_drive, _pulldn_slew, _pullup_slew) \
+	{                                               \
+		.pingroup = TEGRA_DRIVE_PINGROUP_##_name,   \
+		.hsm = TEGRA_HSM_##_hsm,                    \
+		.schmitt = TEGRA_SCHMITT_##_schmitt,        \
+		.drive = TEGRA_DRIVE_##_drive,              \
+		.pull_down = TEGRA_PULL_##_pulldn_drive,    \
+		.pull_up = TEGRA_PULL_##_pullup_drive,		\
+		.slew_rising = TEGRA_SLEW_##_pulldn_slew,   \
+		.slew_falling = TEGRA_SLEW_##_pullup_slew,	\
+	}
+
+/* !!!FIXME!!!! POPULATE THIS TABLE */
+static __initdata struct tegra_drive_pingroup_config ktt30_drive_pinmux[] = {
+	/* DEFAULT_DRIVE(<pin_group>), */
+	/* SET_DRIVE(ATA, DISABLE, DISABLE, DIV_1, 31, 31, FAST, FAST) */
+	SET_DRIVE(DAP2, 	DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+	SET_DRIVE(DAP1, 	DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* All I2C pins are driven to maximum drive strength */
+	/* GEN1 I2C */
+	SET_DRIVE(DBG,		DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* GEN2 I2C */
+	SET_DRIVE(AT5,		DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* CAM I2C */
+	SET_DRIVE(GME,		DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* DDC I2C */
+	SET_DRIVE(DDC,		DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* PWR_I2C */
+	SET_DRIVE(AO1,		DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* UART3 */
+	SET_DRIVE(UART3,	DISABLE, ENABLE, DIV_1, 31, 31, FASTEST, FASTEST),
+
+	/* SDMMC1 */
+	SET_DRIVE(SDIO1,	DISABLE, DISABLE, DIV_1, 46, 42, FAST, FAST),
+
+	/* SDMMC3 */
+	SET_DRIVE(SDIO3,	DISABLE, DISABLE, DIV_1, 46, 42, FAST, FAST),
+
+	/* SDMMC4 */
+	SET_DRIVE(GMA,		DISABLE, DISABLE, DIV_1, 9, 9, SLOWEST, SLOWEST),
+	SET_DRIVE(GMB,		DISABLE, DISABLE, DIV_1, 9, 9, SLOWEST, SLOWEST),
+	SET_DRIVE(GMC,		DISABLE, DISABLE, DIV_1, 9, 9, SLOWEST, SLOWEST),
+	SET_DRIVE(GMD,		DISABLE, DISABLE, DIV_1, 9, 9, SLOWEST, SLOWEST),
+};
+
+#define DEFAULT_PINMUX(_pingroup, _mux, _pupd, _tri, _io)	\
+	{							\
+		.pingroup	= TEGRA_PINGROUP_##_pingroup,	\
+		.func		= TEGRA_MUX_##_mux,		\
+		.pupd		= TEGRA_PUPD_##_pupd,		\
+		.tristate	= TEGRA_TRI_##_tri,		\
+		.io		= TEGRA_PIN_##_io,		\
+		.lock		= TEGRA_PIN_LOCK_DEFAULT,	\
+		.od		= TEGRA_PIN_OD_DEFAULT,		\
+		.ioreset	= TEGRA_PIN_IO_RESET_DEFAULT,	\
+	}
+
+#define I2C_PINMUX(_pingroup, _mux, _pupd, _tri, _io, _lock, _od) \
+	{							\
+		.pingroup	= TEGRA_PINGROUP_##_pingroup,	\
+		.func		= TEGRA_MUX_##_mux,		\
+		.pupd		= TEGRA_PUPD_##_pupd,		\
+		.tristate	= TEGRA_TRI_##_tri,		\
+		.io		= TEGRA_PIN_##_io,		\
+		.lock		= TEGRA_PIN_LOCK_##_lock,	\
+		.od		= TEGRA_PIN_OD_##_od,		\
+		.ioreset	= TEGRA_PIN_IO_RESET_DEFAULT,	\
+	}
+
+#define CEC_PINMUX(_pingroup, _mux, _pupd, _tri, _io, _lock, _od) \
+	{                                                       \
+		.pingroup       = TEGRA_PINGROUP_##_pingroup,   \
+			.func           = TEGRA_MUX_##_mux,             \
+			.pupd           = TEGRA_PUPD_##_pupd,           \
+			.tristate       = TEGRA_TRI_##_tri,             \
+			.io             = TEGRA_PIN_##_io,              \
+			.lock           = TEGRA_PIN_LOCK_##_lock,       \
+			.od             = TEGRA_PIN_OD_##_od,           \
+			.ioreset        = TEGRA_PIN_IO_RESET_DEFAULT,   \
+	}
+
+static __initdata struct tegra_pingroup_config ktt30_pinmux_common[] = {
+	/* SDMMC1 pinmux */
+	DEFAULT_PINMUX(SDMMC1_CLK,      SDMMC1,          NORMAL,     NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC1_CMD,      SDMMC1,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC1_DAT3,     SDMMC1,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC1_DAT2,     SDMMC1,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC1_DAT1,     SDMMC1,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC1_DAT0,     SDMMC1,          PULL_UP,    NORMAL,     INPUT),
+
+	/* SDMMC3 pinmux */
+	DEFAULT_PINMUX(SDMMC3_CLK,      SDMMC3,          NORMAL,     NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC3_CMD,      SDMMC3,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT0,     SDMMC3,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT1,     SDMMC3,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT2,     SDMMC3,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT3,     SDMMC3,          PULL_UP,    NORMAL,     INPUT),
+
+	/* SDMMC4 pinmux */
+	DEFAULT_PINMUX(SDMMC4_CLK,      SDMMC4,          NORMAL,     NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_CMD,      SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT0,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT1,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT2,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT3,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT4,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT5,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT6,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_DAT7,     SDMMC4,          PULL_UP,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SDMMC4_RST_N,    RSVD1,           PULL_DOWN,  NORMAL,     INPUT),
+
+	/* I2C1 pinmux */
+	I2C_PINMUX(GEN1_I2C_SCL,	I2C1,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+	I2C_PINMUX(GEN1_I2C_SDA,	I2C1,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+
+	/* I2C2 pinmux */
+	I2C_PINMUX(GEN2_I2C_SCL,	I2C2,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+	I2C_PINMUX(GEN2_I2C_SDA,	I2C2,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+
+	/* I2C3 pinmux */
+	I2C_PINMUX(CAM_I2C_SCL,		I2C3,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+	I2C_PINMUX(CAM_I2C_SDA,		I2C3,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+
+	/* I2C4 pinmux */
+	I2C_PINMUX(DDC_SCL,		I2C4,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+	I2C_PINMUX(DDC_SDA,		I2C4,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+
+	/* Power I2C pinmux */
+	I2C_PINMUX(PWR_I2C_SCL,		I2CPWR,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+	I2C_PINMUX(PWR_I2C_SDA,		I2CPWR,		NORMAL,	NORMAL,	INPUT,	DISABLE,	ENABLE),
+
+	/* HDMI-CEC  pinmux */
+	CEC_PINMUX(HDMI_CEC,    CEC,    NORMAL,        NORMAL, INPUT,  DISABLE,        ENABLE),
+
+	DEFAULT_PINMUX(ULPI_DATA0,      UARTA,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(ULPI_DATA1,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA2,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA3,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA4,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA5,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA6,      UARTA,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(ULPI_DATA7,      UARTA,           NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(LCD_PCLK,        DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_DE,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_HSYNC,       DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_VSYNC,       DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D0,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D1,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D2,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D3,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D4,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D5,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D6,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D7,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D8,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D9,          DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D10,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D11,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D12,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D13,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D14,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D15,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D16,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D17,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D18,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D19,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D20,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D21,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D22,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(LCD_D23,         DISPLAYA,        NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(CRT_HSYNC,       CRT,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(CRT_VSYNC,       CRT,             NORMAL,    NORMAL,     OUTPUT),
+	/* PCIE0_RST */
+	DEFAULT_PINMUX(VI_D0,           RSVD1,           PULL_DOWN, NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(VI_D1,           RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(VI_D2,           RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(VI_D3,           RSVD1,           NORMAL,    NORMAL,     INPUT),
+	/* ETH_EN (Intel 82574L chip) */
+	DEFAULT_PINMUX(VI_D4,           RSVD1,           PULL_UP,   NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(VI_D5,           RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(VI_D7,           RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(VI_D10,          RSVD1,           NORMAL,    NORMAL,     INPUT),
+
+	DEFAULT_PINMUX(UART3_TXD,       UARTC,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(UART3_RXD,       UARTC,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(UART3_CTS_N,     UARTC,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(UART3_RTS_N,     UARTC,           NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(GMI_WP_N,        GMI,             NORMAL,    NORMAL,     INPUT),
+
+	DEFAULT_PINMUX(KB_ROW5,         OWR,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW12,        KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW15,        KBC,             NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(GMI_WAIT,        RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_CS0_N,       RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_CS1_N,       RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_CS3_N,       RSVD1,           PULL_DOWN, NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_CS4_N,       RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_CS6_N,       NAND_ALT,        NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_CS7_N,       NAND_ALT,        NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(GMI_AD8,         PWM0,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_AD10,        RSVD2,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_AD11,        PWM3,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_AD13,        RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_AD15,        RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(GMI_DQS,         RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_A16,         SPI4,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_A17,         SPI4,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_A18,         SPI4,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GMI_A19,         SPI4,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(CAM_MCLK,        VI_ALT2,         PULL_UP,   NORMAL,     INPUT),
+	/* KTT30 CAM_RST_N */
+	DEFAULT_PINMUX(GPIO_PBB0,       RSVD1,           PULL_UP,   NORMAL,     INPUT),
+	DEFAULT_PINMUX(GPIO_PBB5,       VGP5,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GPIO_PBB6,       VGP6,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GPIO_PBB7,       RSVD1,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GPIO_PCC2,       I2S4,            NORMAL,    NORMAL,     INPUT),
+
+	/*  KBC keys */
+	DEFAULT_PINMUX(KB_ROW0,         RSVD3,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW1,         RSVD3,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW2,         RSVD3,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW3,         RSVD2,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW10,        KBC,             NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(KB_ROW11,        KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW13,        KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW4,         RSVD3,           NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW6,         KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW7,         KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW8,         KBC,             NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(KB_ROW9,         KBC,             NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(DAP1_FS,         I2S0,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP1_DIN,        I2S0,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP1_DOUT,       I2S0,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP1_SCLK,       I2S0,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(CLK1_OUT,        EXTPERIPH1,      NORMAL,    NORMAL,     INPUT),
+
+	DEFAULT_PINMUX(SPDIF_IN,        SPDIF,           NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SPDIF_OUT,       SPDIF,           NORMAL,    NORMAL,     OUTPUT),
+
+	DEFAULT_PINMUX(DAP2_FS,         I2S1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP2_DIN,        I2S1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP2_DOUT,       I2S1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(DAP2_SCLK,       I2S1,            NORMAL,    NORMAL,     INPUT),
+
+	DEFAULT_PINMUX(SPI2_CS1_N,      SPI2,            PULL_UP,   NORMAL,     INPUT),
+	DEFAULT_PINMUX(SPI1_MOSI,       SPI1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SPI1_SCK,        SPI1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SPI1_CS0_N,      SPI1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(SPI1_MISO,       SPI1,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(PEX_L0_RST_N,    PCIE,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(PEX_L0_CLKREQ_N, PCIE,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(PEX_WAKE_N,      PCIE,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(PEX_L1_RST_N,    PCIE,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(PEX_L1_CLKREQ_N, PCIE,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(PEX_L2_RST_N,    PCIE,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(PEX_L2_CLKREQ_N, PCIE,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(HDMI_CEC,        CEC,             NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(HDMI_INT,        RSVD0,           NORMAL,    TRISTATE,   INPUT),
+
+	/* Gpios */
+	/* SDMMC1 CD gpio */
+	DEFAULT_PINMUX(GMI_IORDY,       RSVD1,           PULL_UP,   NORMAL,     INPUT),
+	/* SDMMC1 WP gpio */
+	DEFAULT_PINMUX(VI_D11,          RSVD1,           NORMAL,    NORMAL,     INPUT),
+	/* Touch panel GPIO */
+	/* Touch IRQ */
+	DEFAULT_PINMUX(GMI_AD12,        RSVD1,           PULL_UP,   NORMAL,     INPUT),
+
+	/* Touch RESET */
+	DEFAULT_PINMUX(GMI_AD14,        RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+
+	/* Power rails GPIO */
+	DEFAULT_PINMUX(SPI2_SCK,        SPI2,            NORMAL,    NORMAL,     INPUT),
+	DEFAULT_PINMUX(GPIO_PBB4,       VGP4,            NORMAL,    NORMAL,     OUTPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT4,     SDMMC3,          PULL_UP,   NORMAL,     OUTPUT),
+	/* KTT30 */
+	/* LCD1 BRIGHTNESS_DOWN */
+	DEFAULT_PINMUX(VI_D6,           RSVD1,           NORMAL,    NORMAL,      INPUT),
+	/* EN_3V3_FUSE */
+	DEFAULT_PINMUX(VI_D8,           RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	/* EN_3V3_PEX_HVDD */
+	DEFAULT_PINMUX(VI_D9,           RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	/* EN_VDDIO_VID_OC */
+	DEFAULT_PINMUX(VI_PCLK,         RSVD1,           PULL_UP,   NORMAL,      INPUT),
+	/* EN_VDD_SDMCC (power for SD cards) */
+	DEFAULT_PINMUX(VI_HSYNC,        RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	/* EN_3V3_MINICARD */
+	DEFAULT_PINMUX(VI_VSYNC,        RSVD1,           NORMAL,    NORMAL,     OUTPUT),
+	/* for M24C02 I2C 2Kbit EEPROM – 0xA0 */
+	DEFAULT_PINMUX(SPI2_CS2_N,      SPI2,            PULL_UP,    NORMAL,     OUTPUT),
+};
+
+static __initdata struct tegra_pingroup_config ktt30_pinmux_unused[] = {
+	DEFAULT_PINMUX(CLK1_REQ,	DAP,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(SPI2_CS0_N,	SPI2,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP3_DIN,	I2S2,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP3_DOUT,	I2S2,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP3_FS,		I2S2,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP3_SCLK,	I2S2,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PV0,	RSVD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PV1,	RSVD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(ULPI_CLK,	UARTD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(ULPI_DIR,	UARTD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(ULPI_NXT,	UARTD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(ULPI_STP,	UARTD,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PBB3,	VGP3,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PCC1,	RSVD1,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD0,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD1,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD2,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD3,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD4,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD5,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD6,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD7,		NAND,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GMI_AD9,		NAND,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_CS0_N,	DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_CS1_N,	DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_DC0,		DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_DC1,		DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_M1,		DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_PWR0,	DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_PWR1,	DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_PWR2,	DISPLAYA,   PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_SCK,		DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_SDIN,	DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_SDOUT,	DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(LCD_WR_N,	DISPLAYA,   PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(PEX_L0_PRSNT_N,	PCIE,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(PEX_L1_PRSNT_N,	PCIE,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(PEX_L2_PRSNT_N,	PCIE,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(CLK2_OUT,	EXTPERIPH2, PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(CLK2_REQ,	DAP,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PV2,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PV3,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT5,	SDMMC3,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT6,	SDMMC3,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(SDMMC3_DAT7,	SDMMC3,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(CLK_32K_OUT,	BLINK,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(KB_ROW14,	KBC,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(OWR,		OWR,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(SYS_CLK_REQ,	SYSCLK,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(CLK3_OUT,	EXTPERIPH3, NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(CLK3_REQ,	DEV3,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP4_DIN,	I2S3,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP4_DOUT,	I2S3,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP4_FS,		I2S3,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(DAP4_SCLK,	I2S3,	    PULL_DOWN,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU0,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU1,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU2,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU3,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU4,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU5,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(GPIO_PU6,	RSVD1,	    NORMAL,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(UART2_CTS_N,	UARTB,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(UART2_RTS_N,	UARTB,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(UART2_RXD,	IRDA,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(UART2_TXD,	IRDA,	    PULL_UP,	TRISTATE, OUTPUT),
+	DEFAULT_PINMUX(VI_MCLK,		VI,	    PULL_DOWN,	TRISTATE, OUTPUT),
+};
+#define PIN_GPIO_LPM(_name, _gpio, _is_input, _value)	\
+	{	\
+		.name		= _name,	\
+		.gpio_nr	= _gpio,	\
+		.is_gpio	= true,		\
+		.is_input	= _is_input,	\
+		.value		= _value,	\
+	}
+
+static __initdata struct gpio_init_pin_info pin_ktt30_unused[] = {
+	PIN_GPIO_LPM("CLK1_REQ",	TEGRA_GPIO_PEE2, 1, 0),
+	PIN_GPIO_LPM("SPI2_CS0_N",	TEGRA_GPIO_PX3,  1, 0),
+	PIN_GPIO_LPM("DAP3_DIN",	TEGRA_GPIO_PP1,  1, 0),
+	PIN_GPIO_LPM("DAP3_DOUT",	TEGRA_GPIO_PP2,  1, 0),
+	PIN_GPIO_LPM("DAP3_FS",		TEGRA_GPIO_PP0,  1, 0),
+	PIN_GPIO_LPM("DAP3_SCLK",	TEGRA_GPIO_PP3,  1, 0),
+	PIN_GPIO_LPM("GPIO_PV0",	TEGRA_GPIO_PV0,  1, 0),
+	PIN_GPIO_LPM("GPIO_PV1",	TEGRA_GPIO_PV1,  1, 0),
+	PIN_GPIO_LPM("ULPI_CLK",	TEGRA_GPIO_PY0,  1, 0),
+	PIN_GPIO_LPM("ULPI_DIR",	TEGRA_GPIO_PY1,  1, 0),
+	PIN_GPIO_LPM("ULPI_NXT",	TEGRA_GPIO_PY2,  1, 0),
+	PIN_GPIO_LPM("ULPI_STP",	TEGRA_GPIO_PY3,  1, 0),
+	PIN_GPIO_LPM("GPIO_PBB3",	TEGRA_GPIO_PBB3, 1, 0),
+	PIN_GPIO_LPM("GPIO_PCC1",	TEGRA_GPIO_PCC1, 1, 0),
+	PIN_GPIO_LPM("GMI_AD0",		TEGRA_GPIO_PG0,  1, 0),
+	PIN_GPIO_LPM("GMI_AD1",		TEGRA_GPIO_PG1,  1, 0),
+	PIN_GPIO_LPM("GMI_AD2",		TEGRA_GPIO_PG2,  1, 0),
+	PIN_GPIO_LPM("GMI_AD3",		TEGRA_GPIO_PG3,  1, 0),
+	PIN_GPIO_LPM("GMI_AD4",		TEGRA_GPIO_PG4,  1, 0),
+	PIN_GPIO_LPM("GMI_AD5",		TEGRA_GPIO_PG5,  1, 0),
+	PIN_GPIO_LPM("GMI_AD6",		TEGRA_GPIO_PG6,  1, 0),
+	PIN_GPIO_LPM("GMI_AD7",		TEGRA_GPIO_PG7,  1, 0),
+	PIN_GPIO_LPM("GMI_AD9",		TEGRA_GPIO_PH1,  1, 0),
+	PIN_GPIO_LPM("LCD_CS0_N",	TEGRA_GPIO_PN4,  1, 0),
+	PIN_GPIO_LPM("LCD_CS1_N",	TEGRA_GPIO_PW0,  1, 0),
+	PIN_GPIO_LPM("LCD_DC0",		TEGRA_GPIO_PN6,  1, 0),
+	PIN_GPIO_LPM("LCD_DC1",		TEGRA_GPIO_PD2,  1, 0),
+	PIN_GPIO_LPM("LCD_M1",		TEGRA_GPIO_PW1,  1, 0),
+	PIN_GPIO_LPM("LCD_PWR0",	TEGRA_GPIO_PB2,  1, 0),
+	PIN_GPIO_LPM("LCD_PWR1",	TEGRA_GPIO_PC1,  1, 0),
+	PIN_GPIO_LPM("LCD_PWR2",	TEGRA_GPIO_PC6,  1, 0),
+	PIN_GPIO_LPM("LCD_SCK",		TEGRA_GPIO_PZ4,  1, 0),
+	PIN_GPIO_LPM("LCD_SDIN",	TEGRA_GPIO_PZ2,  1, 0),
+	PIN_GPIO_LPM("LCD_SDOUT",	TEGRA_GPIO_PN5,  1, 0),
+	PIN_GPIO_LPM("LCD_WR_N",	TEGRA_GPIO_PZ3,  1, 0),
+	PIN_GPIO_LPM("PEX_L0_PRSNT_N",	TEGRA_GPIO_PDD0, 1, 0),
+	PIN_GPIO_LPM("PEX_L1_PRSNT_N",	TEGRA_GPIO_PDD4, 1, 0),
+	PIN_GPIO_LPM("PEX_L2_PRSNT_N",	TEGRA_GPIO_PDD7, 1, 0),
+	PIN_GPIO_LPM("CLK2_OUT",	TEGRA_GPIO_PW5,  1, 0),
+	PIN_GPIO_LPM("CLK2_REQ",	TEGRA_GPIO_PCC5, 1, 0),
+	PIN_GPIO_LPM("GPIO_PV2",	TEGRA_GPIO_PV2,  1, 0),
+	PIN_GPIO_LPM("GPIO_PV3",	TEGRA_GPIO_PV3,  1, 0),
+	PIN_GPIO_LPM("SDMMC3_DAT5",	TEGRA_GPIO_PD0,  1, 0),
+	PIN_GPIO_LPM("SDMMC3_DAT6",	TEGRA_GPIO_PD3,  1, 0),
+	PIN_GPIO_LPM("SDMMC3_DAT7",	TEGRA_GPIO_PD4,  1, 0),
+	PIN_GPIO_LPM("CLK_32K_OUT",	TEGRA_GPIO_PA0,  1, 0),
+	PIN_GPIO_LPM("KB_ROW14",	TEGRA_GPIO_PS6,  1, 0),
+	PIN_GPIO_LPM("SYS_CLK_REQ",	TEGRA_GPIO_PZ5,  1, 0),
+	PIN_GPIO_LPM("CLK3_OUT",	TEGRA_GPIO_PEE0, 1, 0),
+	PIN_GPIO_LPM("CLK3_REQ",	TEGRA_GPIO_PEE1, 1, 0),
+	PIN_GPIO_LPM("DAP4_DIN",	TEGRA_GPIO_PP5,  1, 0),
+	PIN_GPIO_LPM("DAP4_DOUT",	TEGRA_GPIO_PP6,  1, 0),
+	PIN_GPIO_LPM("DAP4_FS",		TEGRA_GPIO_PP4,  1, 0),
+	PIN_GPIO_LPM("DAP4_SCLK",	TEGRA_GPIO_PP7,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU0",	TEGRA_GPIO_PU0,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU1",	TEGRA_GPIO_PU1,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU2",	TEGRA_GPIO_PU2,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU3",	TEGRA_GPIO_PU3,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU4",	TEGRA_GPIO_PU4,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU5",	TEGRA_GPIO_PU5,  1, 0),
+	PIN_GPIO_LPM("GPIO_PU6",	TEGRA_GPIO_PU6,  1, 0),
+	PIN_GPIO_LPM("UART2_CTS_N",	TEGRA_GPIO_PJ5,  1, 0),
+	PIN_GPIO_LPM("UART2_RTS_N",	TEGRA_GPIO_PJ6,  1, 0),
+	PIN_GPIO_LPM("UART2_RXD",	TEGRA_GPIO_PC3,  1, 0),
+	PIN_GPIO_LPM("UART2_TXD",	TEGRA_GPIO_PC2,  1, 0),
+	PIN_GPIO_LPM("VI_MCLK",		TEGRA_GPIO_PT1,  1, 0),
+};
+
+
+int __init ktt30_pinmux_init(void)
+{
+	tegra_pinmux_config_table(ktt30_pinmux_common,
+				ARRAY_SIZE(ktt30_pinmux_common));
+	tegra_drive_pinmux_config_table(ktt30_drive_pinmux,
+				ARRAY_SIZE(ktt30_drive_pinmux));
+	tegra_pinmux_config_table(ktt30_pinmux_unused,
+				ARRAY_SIZE(ktt30_pinmux_unused));
+	return 0;
+}
+
+
+static void __init set_unused_pin_gpio(struct gpio_init_pin_info *lpm_pin_info,
+					int list_count)
+{
+	int i;
+
+	for (i = 0; i < list_count; i++) {
+		struct gpio_init_pin_info *pin_info = &lpm_pin_info[i];
+		unsigned long flags = GPIOF_OUT_INIT_LOW;
+		int retval;
+
+		if (!pin_info->is_gpio)
+			continue;
+
+		if (pin_info->is_input)
+			flags = GPIOF_DIR_IN;
+		else if (pin_info->value)
+			flags = GPIOF_OUT_INIT_HIGH;
+
+		retval = gpio_request_one(pin_info->gpio_nr, flags,
+						pin_info->name);
+		if (retval < 0)
+			pr_err("%s() Error: gpio_request_one() for gpio %d\n",
+					__func__, pin_info->gpio_nr);
+	}
+}
+
+/*
+ * Initialize the pins to desired state
+ * as per power/asic/system-eng recomendation
+ */
+int __init ktt30_pins_state_init(void)
+{
+	set_unused_pin_gpio(pin_ktt30_unused, ARRAY_SIZE(pin_ktt30_unused));
+	return 0;
+}
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-power.c
@@ -0,0 +1,659 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30-power.c
+ *
+ * Copyright (C) 2011 NVIDIA, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307, USA
+ */
+#include <linux/i2c.h>
+#include <linux/pda_power.h>
+#include <linux/platform_device.h>
+#include <linux/resource.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/tps6591x.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/regulator/fixed.h>
+#include <linux/regulator/tps6591x-regulator.h>
+#include <linux/regulator/tps62360.h>
+#include <linux/power/gpio-charger.h>
+
+#include <asm/mach-types.h>
+
+#include <mach/iomap.h>
+#include <mach/irqs.h>
+#include <mach/pinmux.h>
+#include <mach/edp.h>
+
+#include "gpio-names.h"
+#include "board.h"
+#include "board-ktt30.h"
+#include "pm.h"
+#include "wakeups-t3.h"
+#include "tegra3_tsensor.h"
+
+#define PMC_CTRL		0x0
+#define PMC_CTRL_INTR_LOW	(1 << 17)
+
+static struct regulator_consumer_supply tps6591x_vdd1_supply_0[] = {
+	REGULATOR_SUPPLY("en_vddio_ddr_1v2", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_vdd2_supply_0[] = {
+	REGULATOR_SUPPLY("vdd_gen1v5", NULL),
+	REGULATOR_SUPPLY("vcore_lcd", NULL),
+	REGULATOR_SUPPLY("track_ldo1", NULL),
+	REGULATOR_SUPPLY("external_ldo_1v2", NULL),
+	REGULATOR_SUPPLY("vcore_cam1", NULL),
+	REGULATOR_SUPPLY("vcore_cam2", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_vddctrl_supply_0[] = {
+	REGULATOR_SUPPLY("vdd_cpu_pmu", NULL),
+	REGULATOR_SUPPLY("vdd_cpu", NULL),
+	REGULATOR_SUPPLY("vdd_sys", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_vio_supply_0[] = {
+	REGULATOR_SUPPLY("vdd_gen1v8", NULL),
+	REGULATOR_SUPPLY("avdd_hdmi_pll", NULL),
+	REGULATOR_SUPPLY("avdd_usb_pll", NULL),
+	REGULATOR_SUPPLY("avdd_osc", NULL),
+	REGULATOR_SUPPLY("vddio_sys", NULL),
+	REGULATOR_SUPPLY("vddio_sdmmc", "sdhci-tegra.3"),
+	REGULATOR_SUPPLY("pwrdet_sdmmc4", NULL),
+	REGULATOR_SUPPLY("vdd1v8_satelite", NULL),
+	REGULATOR_SUPPLY("vddio_uart", NULL),
+	REGULATOR_SUPPLY("pwrdet_uart", NULL),
+	REGULATOR_SUPPLY("vddio_audio", NULL),
+	REGULATOR_SUPPLY("pwrdet_audio", NULL),
+	REGULATOR_SUPPLY("vddio_bb", NULL),
+	REGULATOR_SUPPLY("pwrdet_bb", NULL),
+	REGULATOR_SUPPLY("vddio_lcd_pmu", NULL),
+	REGULATOR_SUPPLY("pwrdet_lcd", NULL),
+	REGULATOR_SUPPLY("vddio_cam", NULL),
+	REGULATOR_SUPPLY("pwrdet_cam", NULL),
+	REGULATOR_SUPPLY("vddio_vi", NULL),
+	REGULATOR_SUPPLY("pwrdet_vi", NULL),
+	REGULATOR_SUPPLY("ldo6", NULL),
+	REGULATOR_SUPPLY("ldo7", NULL),
+	REGULATOR_SUPPLY("ldo8", NULL),
+	REGULATOR_SUPPLY("vcore_audio", NULL),
+	REGULATOR_SUPPLY("avcore_audio", NULL),
+	REGULATOR_SUPPLY("vddio_sdmmc", "sdhci-tegra.2"),
+	REGULATOR_SUPPLY("pwrdet_sdmmc3", NULL),
+	REGULATOR_SUPPLY("vcore1_lpddr2", NULL),
+	REGULATOR_SUPPLY("vcom_1v8", NULL),
+	REGULATOR_SUPPLY("pmuio_1v8", NULL),
+	REGULATOR_SUPPLY("avdd_ic_usb", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo1_supply_0[] = {
+	REGULATOR_SUPPLY("avdd_pexb", NULL),
+	REGULATOR_SUPPLY("vdd_pexb", NULL),
+	REGULATOR_SUPPLY("avdd_pex_pll", NULL),
+	REGULATOR_SUPPLY("avdd_pexa", NULL),
+	REGULATOR_SUPPLY("vdd_pexa", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo2_supply_0[] = {
+	REGULATOR_SUPPLY("avdd_sata", NULL),
+	REGULATOR_SUPPLY("vdd_sata", NULL),
+	REGULATOR_SUPPLY("avdd_sata_pll", NULL),
+	REGULATOR_SUPPLY("avdd_plle", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo3_supply_0[] = {
+	REGULATOR_SUPPLY("unused_rail_ldo3", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo4_supply_0[] = {
+	REGULATOR_SUPPLY("vdd_rtc", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo5_supply_0[] = {
+	REGULATOR_SUPPLY("avdd_vdac", NULL),
+	REGULATOR_SUPPLY("vddio_sdmmc", "sdhci-tegra.0"),
+	REGULATOR_SUPPLY("pwrdet_sdmmc1", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo6_supply_0[] = {
+	REGULATOR_SUPPLY("avdd_dsi_csi", NULL),
+	REGULATOR_SUPPLY("pwrdet_mipi", NULL),
+};
+static struct regulator_consumer_supply tps6591x_ldo7_supply_0[] = {
+	REGULATOR_SUPPLY("avdd_plla_p_c_s", NULL),
+	REGULATOR_SUPPLY("avdd_pllm", NULL),
+	REGULATOR_SUPPLY("avdd_pllu_d", NULL),
+	REGULATOR_SUPPLY("avdd_pllu_d2", NULL),
+	REGULATOR_SUPPLY("avdd_pllx", NULL),
+};
+
+static struct regulator_consumer_supply tps6591x_ldo8_supply_0[] = {
+	REGULATOR_SUPPLY("vdd_ddr_hs", NULL),
+};
+
+#define TPS_PDATA_INIT(_name, _sname, _minmv, _maxmv, _supply_reg, _always_on, \
+	_boot_on, _apply_uv, _init_uV, _init_enable, _init_apply, _ectrl, _flags) \
+	static struct tps6591x_regulator_platform_data pdata_##_name##_##_sname = \
+	{								\
+		.regulator = {						\
+			.constraints = {				\
+				.min_uV = (_minmv)*1000,		\
+				.max_uV = (_maxmv)*1000,		\
+				.valid_modes_mask = (REGULATOR_MODE_NORMAL |  \
+						     REGULATOR_MODE_STANDBY), \
+				.valid_ops_mask = (REGULATOR_CHANGE_MODE |    \
+						   REGULATOR_CHANGE_STATUS |  \
+						   REGULATOR_CHANGE_VOLTAGE), \
+				.always_on = _always_on,		\
+				.boot_on = _boot_on,			\
+				.apply_uV = _apply_uv,			\
+			},						\
+			.num_consumer_supplies =			\
+				ARRAY_SIZE(tps6591x_##_name##_supply_##_sname), \
+			.consumer_supplies = tps6591x_##_name##_supply_##_sname, \
+			.supply_regulator = _supply_reg,		\
+		},							\
+		.init_uV =  _init_uV * 1000,				\
+		.init_enable = _init_enable,				\
+		.init_apply = _init_apply,				\
+		.ectrl = _ectrl,					\
+		.flags = _flags,					\
+	}
+
+TPS_PDATA_INIT(vdd1, 0,         1050, 1050, 0, 1, 1, 0, -1, 0, 0, EXT_CTRL_SLEEP_OFF, 0);
+TPS_PDATA_INIT(vdd2, 0,         600,  1500, 0, 1, 1, 0, -1, 0, 0, 0, 0);
+TPS_PDATA_INIT(vddctrl, 0,      600,  1400, 0, 1, 1, 0, -1, 0, 0, EXT_CTRL_EN1, 0);
+TPS_PDATA_INIT(vio,  0,         1800, 1800, 0, 1, 1, 0, -1, 0, 0, 0, 0);
+
+TPS_PDATA_INIT(ldo1, 0,         1050, 1050, tps6591x_rails(VDD_2), 0, 0, 0, -1, 0, 1, 0, 0);
+TPS_PDATA_INIT(ldo2, 0,         1050, 1050, tps6591x_rails(VDD_2), 0, 0, 1, -1, 0, 1, 0, 0);
+
+TPS_PDATA_INIT(ldo3, 0,         1000, 3300, 0, 0, 0, 0, -1, 0, 0, 0, 0);
+TPS_PDATA_INIT(ldo4, 0,         1000, 1200, 0, 1, 0, 0, -1, 0, 0, 0, 0);
+TPS_PDATA_INIT(ldo5, 0,         3300, 3300, 0, 0, 0, 0, -1, 0, 0, 0, 0);
+
+TPS_PDATA_INIT(ldo6, 0,         1200, 1200, tps6591x_rails(VIO), 0, 0, 1, -1, 0, 0, 0, 0);
+TPS_PDATA_INIT(ldo7, 0,         1200, 1200, tps6591x_rails(VIO), 1, 1, 1, -1, 0, 0, EXT_CTRL_SLEEP_OFF, LDO_LOW_POWER_ON_SUSPEND);
+TPS_PDATA_INIT(ldo8, 0,         1000, 1000, tps6591x_rails(VIO), 1, 0, 0, -1, 0, 0, EXT_CTRL_SLEEP_OFF, LDO_LOW_POWER_ON_SUSPEND);
+
+#if defined(CONFIG_RTC_DRV_TPS6591x)
+static struct tps6591x_rtc_platform_data rtc_data = {
+	.irq = TEGRA_NR_IRQS + TPS6591X_INT_RTC_ALARM,
+	.time = {
+		.tm_year = 2000,
+		.tm_mon = 0,
+		.tm_mday = 1,
+		.tm_hour = 0,
+		.tm_min = 0,
+		.tm_sec = 0,
+	},
+};
+
+#define TPS_RTC_REG()					\
+	{						\
+		.id	= 0,				\
+		.name	= "rtc_tps6591x",		\
+		.platform_data = &rtc_data,		\
+	}
+#endif
+
+#define TPS_REG(_id, _name, _sname)				\
+	{							\
+		.id	= TPS6591X_ID_##_id,			\
+		.name	= "tps6591x-regulator",			\
+		.platform_data	= &pdata_##_name##_##_sname,	\
+	}
+
+#define TPS6591X_DEV_COMMON_KTT30		\
+	TPS_REG(VDD_2, vdd2, 0),		\
+	TPS_REG(VDDCTRL, vddctrl, 0),		\
+	TPS_REG(LDO_1, ldo1, 0),		\
+	TPS_REG(LDO_2, ldo2, 0),		\
+	TPS_REG(LDO_3, ldo3, 0),		\
+	TPS_REG(LDO_4, ldo4, 0),		\
+	TPS_REG(LDO_5, ldo5, 0),		\
+	TPS_REG(LDO_6, ldo6, 0),		\
+	TPS_REG(LDO_7, ldo7, 0),		\
+	TPS_REG(LDO_8, ldo8, 0)
+
+static struct tps6591x_subdev_info tps_devs_ktt30_0[] = {
+	TPS_REG(VIO, vio, 0),
+	TPS_REG(VDD_1, vdd1, 0),
+	TPS6591X_DEV_COMMON_KTT30,
+#if defined(CONFIG_RTC_DRV_TPS6591x)
+	TPS_RTC_REG(),
+#endif
+};
+
+
+#define TPS_GPIO_INIT_PDATA(gpio_nr, _init_apply, _sleep_en, _pulldn_en, _output_en, _output_val) \
+	[gpio_nr] = {					\
+			.sleep_en	= _sleep_en,	\
+			.pulldn_en	= _pulldn_en,	\
+			.output_mode_en	= _output_en,	\
+			.output_val	= _output_val,	\
+			.init_apply	= _init_apply,	\
+		     }
+
+static struct tps6591x_gpio_init_data tps_gpio_pdata_ktt30[] =  {
+	TPS_GPIO_INIT_PDATA(0, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(1, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(2, 1, 1, 0, 1, 1),
+	TPS_GPIO_INIT_PDATA(3, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(4, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(5, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(6, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(7, 0, 0, 0, 0, 0),
+	TPS_GPIO_INIT_PDATA(8, 0, 0, 0, 0, 0),
+};
+
+static struct tps6591x_sleep_keepon_data tps_slp_keepon = {
+	.clkout32k_keepon = 1,
+};
+
+static struct tps6591x_platform_data tps_platform = {
+	.irq_base	= TPS6591X_IRQ_BASE,
+	.gpio_base	= TPS6591X_GPIO_BASE,
+	.dev_slp_en	= true,
+	.slp_keepon	= &tps_slp_keepon,
+	.use_power_off	= true,
+	.num_subdevs	= ARRAY_SIZE(tps_devs_ktt30_0),
+	.subdevs	= tps_devs_ktt30_0,
+	.gpio_init_data	= tps_gpio_pdata_ktt30,
+	.num_gpioinit_data = ARRAY_SIZE(tps_gpio_pdata_ktt30),
+};
+
+static struct i2c_board_info __initdata ktt30_regulators[] = {
+	{
+		I2C_BOARD_INFO("tps6591x", 0x2D),
+		.irq		= INT_EXTERNAL_PMU,
+		.platform_data	= &tps_platform,
+	},
+};
+
+/* TPS62361B DC-DC converter */
+static struct regulator_consumer_supply tps62361_dcdc_supply[] = {
+	REGULATOR_SUPPLY("vdd_core", NULL),
+};
+
+static struct tps62360_regulator_platform_data tps62361_pdata = {
+	.reg_init_data = {
+		.constraints = {
+			.min_uV = 500000,
+			.max_uV = 1770000,
+			.valid_modes_mask = (REGULATOR_MODE_NORMAL |
+					     REGULATOR_MODE_STANDBY),
+			.valid_ops_mask = (REGULATOR_CHANGE_MODE |
+					   REGULATOR_CHANGE_STATUS |
+					   REGULATOR_CHANGE_VOLTAGE),
+			.always_on = 1,
+			.boot_on =  1,
+			.apply_uV = 0,
+		},
+		.num_consumer_supplies = ARRAY_SIZE(tps62361_dcdc_supply),
+		.consumer_supplies = tps62361_dcdc_supply,
+		},
+	.en_discharge = true,
+	.vsel0_gpio = -1,
+	.vsel1_gpio = -1,
+	.vsel0_def_state = 1,
+	.vsel1_def_state = 1,
+};
+
+static struct i2c_board_info __initdata tps62361_boardinfo[] = {
+	{
+		I2C_BOARD_INFO("tps62361", 0x60),
+		.platform_data	= &tps62361_pdata,
+	},
+};
+
+int __init ktt30_regulator_init(void)
+{
+	struct board_info board_info;
+	void __iomem *pmc = IO_ADDRESS(TEGRA_PMC_BASE);
+	u32 pmc_ctrl;
+
+	/* configure the power management controller to trigger PMU
+	 * interrupts when low */
+	pmc_ctrl = readl(pmc + PMC_CTRL);
+	writel(pmc_ctrl | PMC_CTRL_INTR_LOW, pmc + PMC_CTRL);
+
+	tegra_get_board_info(&board_info);
+
+	/* The regulator details have complete constraints */
+	regulator_has_full_constraints();
+
+	pr_info("BoardId:SKU:Fab 0x%04x:0x%04x:0x%02x\n",
+		board_info.board_id, board_info.sku , board_info.fab);
+	pr_info("VSEL 1:0 %d%d\n",
+		tps62361_pdata.vsel1_def_state,
+		tps62361_pdata.vsel0_def_state);
+
+	i2c_register_board_info(4, ktt30_regulators, 1);
+
+	/* Register the external core regulator */
+	pr_info("Registering the core regulator\n");
+	i2c_register_board_info(4, tps62361_boardinfo, 1);
+
+	return 0;
+}
+
+
+/**************** GPIO based fixed regulator *****************/
+/* EN_5V0 From PMU GP2 */
+static struct regulator_consumer_supply fixed_reg_en_5v0_supply[] = {
+	REGULATOR_SUPPLY("vdd_5v0_sys", NULL),
+};
+
+/* EN_DDR From PMU GP6 */
+static struct regulator_consumer_supply fixed_reg_en_ddr_supply[] = {
+	REGULATOR_SUPPLY("mem_vddio_ddr", NULL),
+	REGULATOR_SUPPLY("t30_vddio_ddr", NULL),
+};
+
+/* EN_3V3_SYS From PMU GP7 */
+static struct regulator_consumer_supply fixed_reg_en_3v3_sys_supply[] = {
+	REGULATOR_SUPPLY("vdd_lvds", NULL),
+	REGULATOR_SUPPLY("vdd_pnl", NULL),
+	REGULATOR_SUPPLY("vcom_3v3", NULL),
+	REGULATOR_SUPPLY("vdd_3v3", NULL),
+	REGULATOR_SUPPLY("vcore_mmc", NULL),
+	REGULATOR_SUPPLY("vddio_pex_ctl", NULL),
+	REGULATOR_SUPPLY("pwrdet_pex_ctl", NULL),
+	REGULATOR_SUPPLY("hvdd_pex_pmu", NULL),
+	REGULATOR_SUPPLY("avdd_hdmi", NULL),
+	REGULATOR_SUPPLY("vpp_fuse", NULL),
+	REGULATOR_SUPPLY("avdd_usb", NULL),
+	REGULATOR_SUPPLY("vdd_ddr_rx", NULL),
+	REGULATOR_SUPPLY("vcore_nand", NULL),
+	REGULATOR_SUPPLY("hvdd_sata", NULL),
+	REGULATOR_SUPPLY("vddio_gmi_pmu", NULL),
+	REGULATOR_SUPPLY("pwrdet_nand", NULL),
+	REGULATOR_SUPPLY("avdd_cam1", NULL),
+	REGULATOR_SUPPLY("vdd_af", NULL),
+	REGULATOR_SUPPLY("avdd_cam2", NULL),
+	REGULATOR_SUPPLY("vdd_acc", NULL),
+	REGULATOR_SUPPLY("vdd_phtl", NULL),
+	REGULATOR_SUPPLY("vddio_tp", NULL),
+	REGULATOR_SUPPLY("vdd_led", NULL),
+	REGULATOR_SUPPLY("vddio_cec", NULL),
+	REGULATOR_SUPPLY("vdd_cmps", NULL),
+	REGULATOR_SUPPLY("vdd_temp", NULL),
+	REGULATOR_SUPPLY("vpp_kfuse", NULL),
+	REGULATOR_SUPPLY("vddio_ts", NULL),
+	REGULATOR_SUPPLY("vdd_ir_led", NULL),
+	REGULATOR_SUPPLY("vddio_1wire", NULL),
+	REGULATOR_SUPPLY("avddio_audio", NULL),
+	REGULATOR_SUPPLY("vdd_ec", NULL),
+	REGULATOR_SUPPLY("vcom_pa", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_devices", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_dock", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_edid", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_hdmi_cec", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_gmi", NULL),
+	REGULATOR_SUPPLY("vdd_spk_amp", "tegra-snd-wm8903.0"),
+	REGULATOR_SUPPLY("vdd_3v3_sensor", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_cam", NULL),
+	REGULATOR_SUPPLY("vdd_3v3_als", NULL),
+	REGULATOR_SUPPLY("debug_cons", NULL),
+	REGULATOR_SUPPLY("vdd", "4-004c"),
+};
+
+/* DIS_5V_SWITCH from AP SPI2_SCK X02 */
+static struct regulator_consumer_supply fixed_reg_dis_5v_switch_supply[] = {
+	REGULATOR_SUPPLY("master_5v_switch", NULL),
+};
+
+/* EN_VDD_BL */
+static struct regulator_consumer_supply fixed_reg_en_vdd_bl_supply[] = {
+	REGULATOR_SUPPLY("vdd_backlight", NULL),
+	REGULATOR_SUPPLY("vdd_backlight1", NULL),
+};
+
+/* EN_VDD_PNL1 from AP GPIO VI_D6 L04*/
+#ifndef CONFIG_TEGRA_KTT30_DSI
+static struct regulator_consumer_supply fixed_reg_en_vdd_pnl1_supply[] = {
+	REGULATOR_SUPPLY("vdd_lcd_panel", NULL),
+};
+#endif
+
+/* EN_VDD_SDMMC1 from AP GPIO VI_HSYNC D07*/
+static struct regulator_consumer_supply fixed_reg_en_vdd_sdmmc1_supply[] = {
+	REGULATOR_SUPPLY("vddio_sd_slot", "sdhci-tegra.0"),
+	REGULATOR_SUPPLY("vddio_sd_slot", "sdhci-tegra.2"),
+};
+
+/* EN_3V3_EMMC from AP GPIO SDMMC3_DAT4 D01*/
+static struct regulator_consumer_supply fixed_reg_en_3v3_emmc_supply[] = {
+	REGULATOR_SUPPLY("vdd_emmc_core", NULL),
+};
+
+/* EN_3V3_PEX_HVDD from AP GPIO VI_D09 L07*/
+static struct regulator_consumer_supply fixed_reg_en_3v3_pex_hvdd_supply[] = {
+	REGULATOR_SUPPLY("hvdd_pex", NULL),
+};
+
+/* EN_3v3_FUSE from AP GPIO VI_D08 L06*/
+static struct regulator_consumer_supply fixed_reg_en_3v3_fuse_supply[] = {
+	REGULATOR_SUPPLY("vdd_fuse", NULL),
+};
+
+/* EN_1V8_CAM from AP GPIO GPIO_PBB4 PBB04*/
+static struct regulator_consumer_supply fixed_reg_en_1v8_cam_supply[] = {
+	REGULATOR_SUPPLY("vdd_1v8_cam1", NULL),
+	REGULATOR_SUPPLY("vdd_1v8_cam2", NULL),
+	REGULATOR_SUPPLY("vdd_1v8_cam3", NULL),
+	REGULATOR_SUPPLY("dvdd", "6-0072"),
+	REGULATOR_SUPPLY("dvdd", "7-0072"),
+	REGULATOR_SUPPLY("vdd_i2c", "2-0033"),
+};
+
+/* EN_USB1_VBUS_OC*/
+static struct regulator_consumer_supply fixed_reg_en_usb1_vbus_oc_supply[] = {
+	REGULATOR_SUPPLY("vdd_vbus_micro_usb", NULL),
+};
+
+/*EN_USB3_VBUS_OC*/
+static struct regulator_consumer_supply fixed_reg_en_usb3_vbus_oc_supply[] = {
+	REGULATOR_SUPPLY("vdd_vbus_typea_usb", NULL),
+};
+
+/* EN_VDDIO_VID_OC from AP GPIO VI_PCLK T00*/
+static struct regulator_consumer_supply fixed_reg_en_vddio_vid_oc_supply[] = {
+	REGULATOR_SUPPLY("vdd_hdmi_con", NULL),
+};
+
+/* Macro for defining fixed regulator sub device data */
+#define FIXED_SUPPLY(_name) "fixed_reg_"#_name
+#define FIXED_REG_OD(_id, _var, _name, _in_supply, _always_on,		\
+		_boot_on, _gpio_nr, _active_high, _boot_state,		\
+		_millivolts, _od_state)					\
+	static struct regulator_init_data ri_data_##_var =		\
+	{								\
+		.supply_regulator = _in_supply,				\
+		.num_consumer_supplies =				\
+			ARRAY_SIZE(fixed_reg_##_name##_supply),		\
+		.consumer_supplies = fixed_reg_##_name##_supply,	\
+		.constraints = {					\
+			.valid_modes_mask = (REGULATOR_MODE_NORMAL |	\
+					REGULATOR_MODE_STANDBY),	\
+			.valid_ops_mask = (REGULATOR_CHANGE_MODE |	\
+					REGULATOR_CHANGE_STATUS |	\
+					REGULATOR_CHANGE_VOLTAGE),	\
+			.always_on = _always_on,			\
+			.boot_on = _boot_on,				\
+		},							\
+	};								\
+	static struct fixed_voltage_config fixed_reg_##_var##_pdata =	\
+	{								\
+		.supply_name = FIXED_SUPPLY(_name),			\
+		.microvolts = _millivolts * 1000,			\
+		.gpio = _gpio_nr,					\
+		.enable_high = _active_high,				\
+		.enabled_at_boot = _boot_state,				\
+		.init_data = &ri_data_##_var,				\
+		.gpio_is_open_drain = _od_state,			\
+	};								\
+	static struct platform_device fixed_reg_##_var##_dev = {	\
+		.name   = "reg-fixed-voltage",				\
+		.id     = _id,						\
+		.dev    = {						\
+			.platform_data = &fixed_reg_##_var##_pdata,	\
+		},							\
+	}
+
+#define FIXED_REG(_id, _var, _name, _in_supply, _always_on, _boot_on,	\
+		 _gpio_nr, _active_high, _boot_state, _millivolts)	\
+	FIXED_REG_OD(_id, _var, _name, _in_supply, _always_on, _boot_on,  \
+		_gpio_nr, _active_high, _boot_state, _millivolts, false)
+
+
+FIXED_REG(1, en_5v0,		en_5v0,		NULL,				0,      0,      TPS6591X_GPIO_2,	true,	0, 5000);
+FIXED_REG(2, en_ddr,		en_ddr,		NULL,				1,      0,      TPS6591X_GPIO_7,	true,	1, 1500);
+FIXED_REG(3, en_3v3_sys,	en_3v3_sys,	NULL,				0,      0,      TPS6591X_GPIO_6,	true,	1, 3300);
+FIXED_REG(9, en_3v3_fuse,	en_3v3_fuse,	FIXED_SUPPLY(en_3v3_sys),	0,      0,      TEGRA_GPIO_PL6,		true,	0, 3300);
+FIXED_REG(10, en_3v3_emmc,	en_3v3_emmc,	FIXED_SUPPLY(en_3v3_sys),	1,      0,      TEGRA_GPIO_PD1,		true,	1, 3300);
+FIXED_REG(11, en_vdd_sdmmc1,	en_vdd_sdmmc1,	FIXED_SUPPLY(en_3v3_sys),	0,      0,      TEGRA_GPIO_PD7,		true,	1, 3300);
+FIXED_REG(12, en_3v3_pex_hvdd,	en_3v3_pex_hvdd, FIXED_SUPPLY(en_3v3_sys),	0,      0,      TEGRA_GPIO_PL7,		true,	0, 3300);
+FIXED_REG(13, en_1v8_cam,	en_1v8_cam,	tps6591x_rails(VIO),		0,      0,      TEGRA_GPIO_PBB4,	true,	0, 1800);
+
+FIXED_REG(14, dis_5v_switch,	dis_5v_switch,	FIXED_SUPPLY(en_5v0),	0,      0,      TEGRA_GPIO_PX2,		false,	0, 5000);
+
+FIXED_REG(4, en_vdd_bl,		en_vdd_bl,	NULL,				0,      0,      TEGRA_GPIO_PH2,	true,	1, 5000);
+FIXED_REG(6, en_vdd_pnl1,	en_vdd_pnl1,	FIXED_SUPPLY(en_3v3_sys),	0,      0,      TEGRA_GPIO_PK4,	true,	1, 3300);
+
+/****************** Open collector Load switches *******/
+FIXED_REG_OD(15, en_usb1_vbus_oc,	en_usb1_vbus_oc,	FIXED_SUPPLY(dis_5v_switch),	0,      0,      TEGRA_GPIO_PI4,		true,	0, 5000, true);
+FIXED_REG_OD(16, en_usb3_vbus_oc,	en_usb3_vbus_oc,	FIXED_SUPPLY(dis_5v_switch),	0,      0,      TEGRA_GPIO_PH7,		true,	0, 5000, true);
+FIXED_REG_OD(17, en_vddio_vid_oc,	en_vddio_vid_oc,	FIXED_SUPPLY(dis_5v_switch),	0,      0,      TEGRA_GPIO_PT0,		true,	0, 5000, true);
+
+/*
+ * Creating the fixed/gpio-switch regulator device tables for different boards
+ */
+#define ADD_FIXED_REG(_name)	(&fixed_reg_##_name##_dev)
+
+#define KTT30_DISPLAY_FIXED_REG			\
+	ADD_FIXED_REG(en_vdd_bl),		\
+	ADD_FIXED_REG(en_vdd_pnl1),
+
+#define KTT30_FIXED_REG				\
+	ADD_FIXED_REG(en_5v0),			\
+	ADD_FIXED_REG(en_ddr),			\
+	ADD_FIXED_REG(en_3v3_sys),		\
+	ADD_FIXED_REG(en_3v3_fuse),		\
+	ADD_FIXED_REG(en_3v3_emmc),		\
+	ADD_FIXED_REG(en_vdd_sdmmc1),		\
+	ADD_FIXED_REG(en_3v3_pex_hvdd),		\
+	ADD_FIXED_REG(en_1v8_cam),		\
+	ADD_FIXED_REG(dis_5v_switch),		\
+	ADD_FIXED_REG(en_usb1_vbus_oc),		\
+	ADD_FIXED_REG(en_usb3_vbus_oc),		\
+	ADD_FIXED_REG(en_vddio_vid_oc),
+
+static struct platform_device *fixed_reg_devs_ktt30[] = {
+	KTT30_FIXED_REG
+	KTT30_DISPLAY_FIXED_REG
+};
+
+int __init ktt30_fixed_regulator_init(void)
+{
+	if (!machine_is_ktt30())
+		return 0;
+
+	return platform_add_devices(fixed_reg_devs_ktt30,
+			ARRAY_SIZE(fixed_reg_devs_ktt30));
+}
+subsys_initcall_sync(ktt30_fixed_regulator_init);
+
+static void ktt30_board_suspend(int lp_state, enum suspend_stage stg)
+{
+	if ((lp_state == TEGRA_SUSPEND_LP1) && (stg == TEGRA_SUSPEND_BEFORE_CPU))
+		tegra_console_uart_suspend();
+}
+
+static void ktt30_board_resume(int lp_state, enum resume_stage stg)
+{
+	if ((lp_state == TEGRA_SUSPEND_LP1) && (stg == TEGRA_RESUME_AFTER_CPU))
+		tegra_console_uart_resume();
+}
+
+static struct tegra_suspend_platform_data ktt30_suspend_data = {
+	.cpu_timer	= 2000,
+	.cpu_off_timer	= 200,
+	.suspend_mode	= TEGRA_SUSPEND_LP0,
+	.core_timer	= 0x7e7e,
+	.core_off_timer = 0,
+	.corereq_high	= true,
+	.sysclkreq_high	= true,
+	.cpu_lp2_min_residency = 2000,
+	.board_suspend = ktt30_board_suspend,
+	.board_resume = ktt30_board_resume,
+};
+
+int __init ktt30_suspend_init(void)
+{
+	tegra_init_suspend(&ktt30_suspend_data);
+	return 0;
+}
+
+#ifdef CONFIG_TEGRA_EDP_LIMITS
+
+int __init ktt30_edp_init(void)
+{
+	unsigned int regulator_mA;
+
+	regulator_mA = get_maximum_cpu_current_supported();
+	if (!regulator_mA) {
+		regulator_mA = 6000; /* regular T30/s */
+	}
+	pr_info("%s: CPU regulator %d mA\n", __func__, regulator_mA);
+
+	tegra_init_cpu_edp_limits(regulator_mA);
+	return 0;
+}
+#endif
+
+static char *ktt30_battery[] = {
+	"bq27510-0",
+};
+
+static struct gpio_charger_platform_data ktt30_charger_pdata = {
+	.name = "ac",
+	.type = POWER_SUPPLY_TYPE_MAINS,
+	.gpio = AC_PRESENT_GPIO,
+	.gpio_active_low = 0,
+	.supplied_to = ktt30_battery,
+	.num_supplicants = ARRAY_SIZE(ktt30_battery),
+};
+
+static struct platform_device ktt30_charger_device = {
+	.name = "gpio-charger",
+	.dev = {
+		.platform_data = &ktt30_charger_pdata,
+	},
+};
+
+static int __init ktt30_charger_late_init(void)
+{
+	if (!machine_is_ktt30())
+		return 0;
+
+	platform_device_register(&ktt30_charger_device);
+	return 0;
+}
+
+late_initcall(ktt30_charger_late_init);
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-powermon.c
@@ -0,0 +1,48 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30-powermon.c
+ *
+ * Copyright (c) 2011, NVIDIA, All Rights Reserved.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/ina219.h>
+
+#include "board.h"
+#include "board-ktt30.h"
+
+static struct ina219_platform_data power_mon_info = {
+	.calibration_data  = 0xa000,
+	.power_lsb = 2,
+	.rail_name = "VDD_AC_BAT",
+	.divisor = 20,
+};
+
+static struct i2c_board_info __initdata ktt30_i2c0_ina219_board_info[] = {
+	{
+		I2C_BOARD_INFO("ina219", 0x40),
+		.platform_data = &power_mon_info,
+		.irq = -1,
+	},
+};
+
+int __init ktt30_pmon_init(void)
+{
+	/* KTT30 has only one monitor chip to register */
+	return i2c_register_board_info(0, ktt30_i2c0_ina219_board_info,
+		ARRAY_SIZE(ktt30_i2c0_ina219_board_info));
+}
+
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-sdhci.c
@@ -0,0 +1,150 @@
+/*
+ * arch/arm/mach-tegra/board-harmony-sdhci.c
+ *
+ * Copyright (C) 2010 Google, Inc.
+ * Copyright (C) 2011 NVIDIA Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/resource.h>
+#include <linux/platform_device.h>
+#include <linux/wlan_plat.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/mmc/host.h>
+
+#include <asm/mach-types.h>
+#include <mach/irqs.h>
+#include <mach/iomap.h>
+#include <mach/sdhci.h>
+
+#include "gpio-names.h"
+#include "board.h"
+#include "board-ktt30.h"
+
+#define KTT30_SD0_CD TEGRA_GPIO_PI5
+#define KTT30_SD0_WP TEGRA_GPIO_PT3
+
+#define KTT30_SD2_CD TEGRA_GPIO_PI2
+#define KTT30_SD2_WP TEGRA_GPIO_PT2
+
+static struct resource sdhci_resource0[] = {
+	[0] = {
+		.start  = INT_SDMMC1,
+		.end    = INT_SDMMC1,
+		.flags  = IORESOURCE_IRQ,
+	},
+	[1] = {
+		.start	= TEGRA_SDMMC1_BASE,
+		.end	= TEGRA_SDMMC1_BASE + TEGRA_SDMMC1_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource sdhci_resource2[] = {
+	[0] = {
+		.start  = INT_SDMMC3,
+		.end    = INT_SDMMC3,
+		.flags  = IORESOURCE_IRQ,
+	},
+	[1] = {
+		.start	= TEGRA_SDMMC3_BASE,
+		.end	= TEGRA_SDMMC3_BASE + TEGRA_SDMMC3_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct resource sdhci_resource3[] = {
+	[0] = {
+		.start  = INT_SDMMC4,
+		.end    = INT_SDMMC4,
+		.flags  = IORESOURCE_IRQ,
+	},
+	[1] = {
+		.start	= TEGRA_SDMMC4_BASE,
+		.end	= TEGRA_SDMMC4_BASE + TEGRA_SDMMC4_SIZE-1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct tegra_sdhci_platform_data tegra_sdhci_platform_data0 = {
+	.cd_gpio = KTT30_SD0_CD,
+	.wp_gpio = KTT30_SD0_WP,
+	.power_gpio = -1,
+};
+
+/*
+ * SDMMC3_CD_N routed to the pin GMI_DQS.  The corresponding GPIO channel does
+ * not support wake-up.  So the driver complains "SD card wake-up event
+ * registration"
+ */
+static struct tegra_sdhci_platform_data tegra_sdhci_platform_data2 = {
+	.cd_gpio = KTT30_SD2_CD,
+	.wp_gpio = KTT30_SD2_WP,
+	.power_gpio = -1,
+	.mmc_data = {
+		.built_in = 0,
+		.ocr_mask = MMC_OCR_1V8_MASK,
+	}
+};
+
+static struct tegra_sdhci_platform_data tegra_sdhci_platform_data3 = {
+	.cd_gpio = -1,
+	.wp_gpio = -1,
+	.power_gpio = -1,
+	.is_8bit = 1,
+	.tap_delay = 0x0F,
+	.mmc_data = {
+		.built_in = 1,
+	}
+};
+
+static struct platform_device tegra_sdhci_device0 = {
+	.name		= "sdhci-tegra",
+	.id		= 0,
+	.resource	= sdhci_resource0,
+	.num_resources	= ARRAY_SIZE(sdhci_resource0),
+	.dev = {
+		.platform_data = &tegra_sdhci_platform_data0,
+	},
+};
+
+static struct platform_device tegra_sdhci_device2 = {
+	.name		= "sdhci-tegra",
+	.id		= 2,
+	.resource	= sdhci_resource2,
+	.num_resources	= ARRAY_SIZE(sdhci_resource2),
+	.dev = {
+		.platform_data = &tegra_sdhci_platform_data2,
+	},
+};
+
+static struct platform_device tegra_sdhci_device3 = {
+	.name		= "sdhci-tegra",
+	.id		= 3,
+	.resource	= sdhci_resource3,
+	.num_resources	= ARRAY_SIZE(sdhci_resource3),
+	.dev = {
+		.platform_data = &tegra_sdhci_platform_data3,
+	},
+};
+
+int __init ktt30_sdhci_init(void)
+{
+	platform_device_register(&tegra_sdhci_device0);
+	platform_device_register(&tegra_sdhci_device2);
+	platform_device_register(&tegra_sdhci_device3);
+
+	return 0;
+}
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30-sensors.c
@@ -0,0 +1,121 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30-sensors.c
+ *
+ * Copyright (c) 2010-2011, NVIDIA CORPORATION, All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * Neither the name of NVIDIA CORPORATION nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+ * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+ * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/i2c.h>
+#include <linux/mpu.h>
+#include <mach/fb.h>
+#include <mach/gpio.h>
+#include <generated/mach-types.h>
+
+#include "board.h"
+#include "gpio-names.h"
+#include "board-ktt30.h"
+
+
+static struct mpu_platform_data mpu_gyro_data = {
+	.int_config	= 0x10,
+	.level_shifter	= 0,
+	.orientation	= MPU_GYRO_ORIENTATION,
+};
+
+static struct ext_slave_platform_data mpu_accel_data = {
+	.address	= MPU_ACCEL_ADDR,
+	.irq		= 0,
+	.adapt_num	= MPU_ACCEL_BUS_NUM,
+	.bus		= EXT_SLAVE_BUS_SECONDARY,
+	.orientation	= MPU_ACCEL_ORIENTATION,
+};
+
+static struct i2c_board_info __initdata inv_mpu_i2c2_board_info[] = {
+	{
+		I2C_BOARD_INFO(MPU_GYRO_NAME, MPU_GYRO_ADDR),
+		.irq = TEGRA_GPIO_TO_IRQ(MPU_GYRO_IRQ_GPIO),
+		.platform_data = &mpu_gyro_data,
+	},
+	{
+		I2C_BOARD_INFO(MPU_ACCEL_NAME, MPU_ACCEL_ADDR),
+#if MPU_ACCEL_IRQ_GPIO
+		.irq = TEGRA_GPIO_TO_IRQ(MPU_ACCEL_IRQ_GPIO),
+#endif
+		.platform_data = &mpu_accel_data,
+	},
+};
+
+static int mpuirq_init(void)
+{
+	int ret;
+
+	pr_info("*** MPU START *** mpuirq_init...\n");
+
+#if MPU_ACCEL_IRQ_GPIO
+	/* ACCEL-IRQ assignment */
+	tegra_gpio_enable(MPU_ACCEL_IRQ_GPIO);
+	ret = gpio_request(MPU_ACCEL_IRQ_GPIO, MPU_ACCEL_NAME);
+	if (ret < 0) {
+		pr_err("%s: gpio_request failed %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = gpio_direction_input(MPU_ACCEL_IRQ_GPIO);
+	if (ret < 0) {
+		pr_err("%s: gpio_direction_input failed %d\n", __func__, ret);
+		gpio_free(MPU_ACCEL_IRQ_GPIO);
+		return ret;
+	}
+#endif
+
+	/* MPU-IRQ assignment */
+	tegra_gpio_enable(MPU_GYRO_IRQ_GPIO);
+	ret = gpio_request(MPU_GYRO_IRQ_GPIO, MPU_GYRO_NAME);
+	if (ret < 0) {
+		pr_err("%s: gpio_request failed %d\n", __func__, ret);
+		return ret;
+	}
+
+	ret = gpio_direction_input(MPU_GYRO_IRQ_GPIO);
+	if (ret < 0) {
+		pr_err("%s: gpio_direction_input failed %d\n", __func__, ret);
+		gpio_free(MPU_GYRO_IRQ_GPIO);
+		return ret;
+	}
+	pr_info("*** MPU END *** mpuirq_init...\n");
+
+	return i2c_register_board_info(MPU_GYRO_BUS_NUM,
+				inv_mpu_i2c2_board_info,
+				ARRAY_SIZE(inv_mpu_i2c2_board_info));
+}
+
+int __init ktt30_sensors_init(void)
+{
+	return mpuirq_init();
+}
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30.c
@@ -0,0 +1,831 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30.c
+ *
+ * Copyright (c) 2011-2012, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/serial_8250.h>
+#include <linux/i2c.h>
+#include <linux/i2c/panjit_ts.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/i2c-tegra.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/platform_data/tegra_usb.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c/atmel_mxt_ts.h>
+#include <linux/tegra_uart.h>
+#include <linux/memblock.h>
+#include <linux/spi-tegra.h>
+#include <linux/nfc/pn544.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/flash.h>
+
+#include <sound/wm8903.h>
+#include <media/tegra_dtv.h>
+
+#include <mach/clk.h>
+#include <mach/iomap.h>
+#include <mach/irqs.h>
+#include <mach/pinmux.h>
+#include <mach/iomap.h>
+#include <mach/io_dpd.h>
+#include <mach/io.h>
+#include <mach/i2s.h>
+#include <mach/tegra_asoc_pdata.h>
+#include <mach/tegra_wm8903_pdata.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/usb_phy.h>
+#include <mach/thermal.h>
+#include <mach/pci.h>
+
+#include "board.h"
+#include "clock.h"
+#include "board-ktt30.h"
+#include "devices.h"
+#include "gpio-names.h"
+#include "fuse.h"
+#include "pm.h"
+#include "wdt-recovery.h"
+
+static struct balanced_throttle throttle_list[] = {
+#ifdef CONFIG_TEGRA_THERMAL_THROTTLE
+	{
+		.id = BALANCED_THROTTLE_ID_TJ,
+		.throt_tab_size = 10,
+		.throt_tab = {
+			{      0, 1000 },
+			{ 640000, 1000 },
+			{ 640000, 1000 },
+			{ 640000, 1000 },
+			{ 640000, 1000 },
+			{ 640000, 1000 },
+			{ 760000, 1000 },
+			{ 760000, 1050 },
+			{1000000, 1050 },
+			{1000000, 1100 },
+		},
+	},
+#endif
+#ifdef CONFIG_TEGRA_SKIN_THROTTLE
+	{
+		.id = BALANCED_THROTTLE_ID_SKIN,
+		.throt_tab_size = 6,
+		.throt_tab = {
+			{ 640000, 1200 },
+			{ 640000, 1200 },
+			{ 760000, 1200 },
+			{ 760000, 1200 },
+			{1000000, 1200 },
+			{1000000, 1200 },
+		},
+	},
+#endif
+};
+
+/* All units are in millicelsius */
+static struct tegra_thermal_data thermal_data = {
+	.shutdown_device_id = THERMAL_DEVICE_ID_NCT_EXT,
+	.temp_shutdown = 90000,
+
+#if defined(CONFIG_TEGRA_EDP_LIMITS) || defined(CONFIG_TEGRA_THERMAL_THROTTLE)
+	.throttle_edp_device_id = THERMAL_DEVICE_ID_NCT_EXT,
+#endif
+#ifdef CONFIG_TEGRA_EDP_LIMITS
+	.edp_offset = TDIODE_OFFSET,  /* edp based on tdiode */
+	.hysteresis_edp = 3000,
+#endif
+#ifdef CONFIG_TEGRA_THERMAL_THROTTLE
+	.temp_throttle = 85000,
+	.tc1 = 0,
+	.tc2 = 1,
+	.passive_delay = 2000,
+#endif
+#ifdef CONFIG_TEGRA_SKIN_THROTTLE
+	.skin_device_id = THERMAL_DEVICE_ID_SKIN,
+	.temp_throttle_skin = 43000,
+	.tc1_skin = 0,
+	.tc2_skin = 1,
+	.passive_delay_skin = 5000,
+
+	.skin_temp_offset = 9793,
+	.skin_period = 1100,
+	.skin_devs_size = 2,
+	.skin_devs = {
+		{
+			THERMAL_DEVICE_ID_NCT_EXT,
+			{
+				2, 1, 1, 1,
+				1, 1, 1, 1,
+				1, 1, 1, 0,
+				1, 1, 0, 0,
+				0, 0, -1, -7
+			}
+		},
+		{
+			THERMAL_DEVICE_ID_NCT_INT,
+			{
+				-11, -7, -5, -3,
+				-3, -2, -1, 0,
+				0, 0, 1, 1,
+				1, 2, 2, 3,
+				4, 6, 11, 18
+			}
+		},
+	},
+#endif
+};
+
+static __initdata struct tegra_clk_init_table ktt30_clk_init_table[] = {
+	/* name		parent		rate		enabled */
+	{ "pll_m",	NULL,		0,		false},
+	{ "hda",	"pll_p",	108000000,	false},
+	{ "hda2codec_2x","pll_p",	48000000,	false},
+	{ "pwm",	"pll_p",	3187500,	false},
+	{ "blink",	"clk_32k",	32768,		true},
+	{ "i2s0",	"pll_a_out0",	0,		false},
+	{ "i2s1",	"pll_a_out0",	0,		false},
+	{ "i2s3",	"pll_a_out0",	0,		false},
+	{ "spdif_out",	"pll_a_out0",	0,		false},
+	{ "d_audio",	"clk_m",	12000000,	false},
+	{ "dam0",	"clk_m",	12000000,	false},
+	{ "dam1",	"clk_m",	12000000,	false},
+	{ "dam2",	"clk_m",	12000000,	false},
+	{ "audio1",	"i2s1_sync",	0,		false},
+	{ "audio3",	"i2s3_sync",	0,		false},
+	{ "vi_sensor",	"pll_p",	150000000,	false},
+	{ "i2c1",	"pll_p",	3200000,	false},
+	{ "i2c2",	"pll_p",	3200000,	false},
+	{ "i2c3",	"pll_p",	3200000,	false},
+	{ "i2c4",	"pll_p",	3200000,	false},
+	{ "i2c5",	"pll_p",	3200000,	false},
+	{ NULL,		NULL,		0,		0},
+};
+
+static struct tegra_i2c_platform_data ktt30_i2c1_platform_data = {
+	.adapter_nr	= 0,
+	.bus_count	= 1,
+	.bus_clk_rate	= { 100000, 0 },
+	.scl_gpio		= {TEGRA_GPIO_PC4, 0},
+	.sda_gpio		= {TEGRA_GPIO_PC5, 0},
+	.arb_recovery = arb_lost_recovery,
+};
+
+static struct tegra_i2c_platform_data ktt30_i2c2_platform_data = {
+	.adapter_nr	= 1,
+	.bus_count	= 1,
+	.bus_clk_rate	= { 100000, 0 },
+	.is_clkon_always = true,
+	.scl_gpio		= {TEGRA_GPIO_PT5, 0},
+	.sda_gpio		= {TEGRA_GPIO_PT6, 0},
+	.arb_recovery = arb_lost_recovery,
+};
+
+static struct tegra_i2c_platform_data ktt30_i2c3_platform_data = {
+	.adapter_nr	= 2,
+	.bus_count	= 1,
+	.bus_clk_rate	= { 100000, 0 },
+	.scl_gpio		= {TEGRA_GPIO_PBB1, 0},
+	.sda_gpio		= {TEGRA_GPIO_PBB2, 0},
+	.arb_recovery = arb_lost_recovery,
+};
+
+static struct tegra_i2c_platform_data ktt30_i2c4_platform_data = {
+	.adapter_nr	= 3,
+	.bus_count	= 1,
+	.bus_clk_rate	= { 100000, 0 },
+	.scl_gpio		= {TEGRA_GPIO_PV4, 0},
+	.sda_gpio		= {TEGRA_GPIO_PV5, 0},
+	.arb_recovery = arb_lost_recovery,
+};
+
+static struct tegra_i2c_platform_data ktt30_i2c5_platform_data = {
+	.adapter_nr	= 4,
+	.bus_count	= 1,
+	.bus_clk_rate	= { 400000, 0 },
+	.scl_gpio		= {TEGRA_GPIO_PZ6, 0},
+	.sda_gpio		= {TEGRA_GPIO_PZ7, 0},
+	.arb_recovery = arb_lost_recovery,
+};
+
+static struct wm8903_platform_data ktt30_wm8903_pdata = {
+	.irq_active_low = 0,
+	.micdet_cfg = 0,
+	.micdet_delay = 100,
+	.gpio_base = KTT30_GPIO_WM8903(0),
+	.gpio_cfg = {
+		(WM8903_GPn_FN_DMIC_LR_CLK_OUTPUT << WM8903_GP1_FN_SHIFT),
+		(WM8903_GPn_FN_DMIC_LR_CLK_OUTPUT << WM8903_GP2_FN_SHIFT) |
+			WM8903_GP2_DIR,
+		0,
+		WM8903_GPIO_NO_CONFIG,
+		WM8903_GPIO_NO_CONFIG,
+	},
+};
+
+static struct i2c_board_info __initdata ktt30_codec_wm8903_info = {
+	I2C_BOARD_INFO("wm8903", 0x1a),
+	.platform_data = &ktt30_wm8903_pdata,
+};
+
+static void ktt30_i2c_init(void)
+{
+	tegra_i2c_device1.dev.platform_data = &ktt30_i2c1_platform_data;
+	tegra_i2c_device2.dev.platform_data = &ktt30_i2c2_platform_data;
+	tegra_i2c_device3.dev.platform_data = &ktt30_i2c3_platform_data;
+	tegra_i2c_device4.dev.platform_data = &ktt30_i2c4_platform_data;
+	tegra_i2c_device5.dev.platform_data = &ktt30_i2c5_platform_data;
+
+	platform_device_register(&tegra_i2c_device5);
+	platform_device_register(&tegra_i2c_device4);
+	platform_device_register(&tegra_i2c_device3);
+	platform_device_register(&tegra_i2c_device2);
+	platform_device_register(&tegra_i2c_device1);
+
+	i2c_register_board_info(4, &ktt30_codec_wm8903_info, 1);
+}
+
+static struct platform_device *ktt30_uart_devices[] __initdata = {
+	&tegra_uarta_device,
+	&tegra_uartb_device,
+	&tegra_uartc_device,
+	&tegra_uartd_device,
+	&tegra_uarte_device,
+};
+static struct uart_clk_parent uart_parent_clk[] = {
+	[0] = {.name = "clk_m"},
+	[1] = {.name = "pll_p"},
+#ifndef CONFIG_TEGRA_PLLM_RESTRICTED
+	[2] = {.name = "pll_m"},
+#endif
+};
+
+static struct tegra_uart_platform_data ktt30_uart_pdata;
+static struct tegra_uart_platform_data ktt30_loopback_uart_pdata;
+
+static void __init uart_debug_init(void)
+{
+	/* UARTA is the debug port. */
+	pr_info("Selecting UARTA as the debug console\n");
+	ktt30_uart_devices[0] = &debug_uarta_device;
+	debug_uart_clk = clk_get_sys("serial8250.0", "uarta");
+	debug_uart_port_base = ((struct plat_serial8250_port *)(
+	debug_uarta_device.dev.platform_data))->mapbase;
+
+	return;
+}
+
+static void __init ktt30_uart_init(void)
+{
+	struct clk *c;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(uart_parent_clk); ++i) {
+		c = tegra_get_clock_by_name(uart_parent_clk[i].name);
+		if (IS_ERR_OR_NULL(c)) {
+			pr_err("Not able to get the clock for %s\n",
+						uart_parent_clk[i].name);
+			continue;
+		}
+		uart_parent_clk[i].parent_clk = c;
+		uart_parent_clk[i].fixed_clk_rate = clk_get_rate(c);
+	}
+	ktt30_uart_pdata.parent_clk_list = uart_parent_clk;
+	ktt30_uart_pdata.parent_clk_count = ARRAY_SIZE(uart_parent_clk);
+	ktt30_loopback_uart_pdata.parent_clk_list = uart_parent_clk;
+	ktt30_loopback_uart_pdata.parent_clk_count =
+						ARRAY_SIZE(uart_parent_clk);
+	ktt30_loopback_uart_pdata.is_loopback = true;
+	tegra_uarta_device.dev.platform_data = &ktt30_uart_pdata;
+	tegra_uartb_device.dev.platform_data = &ktt30_uart_pdata;
+	tegra_uartc_device.dev.platform_data = &ktt30_uart_pdata;
+	tegra_uartd_device.dev.platform_data = &ktt30_uart_pdata;
+	/* UARTE is used for loopback test purpose */
+	tegra_uarte_device.dev.platform_data = &ktt30_loopback_uart_pdata;
+
+	/* Register low speed only if it is selected */
+	if (!is_tegra_debug_uartport_hs()) {
+		uart_debug_init();
+		/* Clock enable for the debug channel */
+		if (!IS_ERR_OR_NULL(debug_uart_clk)) {
+			pr_info("The debug console clock name is %s\n",
+						debug_uart_clk->name);
+			c = tegra_get_clock_by_name("pll_p");
+			if (IS_ERR_OR_NULL(c))
+				pr_err("Not getting the parent clock pll_p\n");
+			else
+				clk_set_parent(debug_uart_clk, c);
+
+			clk_enable(debug_uart_clk);
+			clk_set_rate(debug_uart_clk, clk_get_rate(c));
+		} else {
+			pr_err("Not getting the clock %s for debug console\n",
+					debug_uart_clk->name);
+		}
+	}
+
+	platform_add_devices(ktt30_uart_devices,
+				ARRAY_SIZE(ktt30_uart_devices));
+}
+
+static struct platform_device tegra_camera = {
+	.name = "tegra_camera",
+	.id = -1,
+};
+
+static struct platform_device *ktt30_spi_devices[] __initdata = {
+	&tegra_spi_device4,
+};
+
+static struct spi_clk_parent spi_parent_clk[] = {
+	[0] = {.name = "pll_p"},
+#ifndef CONFIG_TEGRA_PLLM_RESTRICTED
+	[1] = {.name = "pll_m"},
+	[2] = {.name = "clk_m"},
+#else
+	[1] = {.name = "clk_m"},
+#endif
+};
+
+static struct tegra_spi_platform_data ktt30_spi_pdata = {
+	.is_dma_based		= true,
+	.max_dma_buffer		= (16 * 1024),
+	.is_clkon_always	= false,
+	.max_rate		= 100000000,
+};
+
+/*
+ * TODO: Check the actual partitioning and adjust the partition table.
+ */
+static struct mtd_partition ktt30_spiflash_part[] = {
+	[0] = {
+		.name		= "UBL",
+		.offset		= 0,
+		.size		= SZ_64K,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+	[1] = {
+		.name		= "unknown",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x003ef000,
+	},
+	[2] = {
+		.name		= "U-Boot-Env",
+		/* the last 4K according to U-Boot */
+		.offset		= SZ_4M - SZ_4K,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= MTD_WRITEABLE,
+	},
+};
+
+
+static struct flash_platform_data ktt30_spiflash_data = {
+	.type		= "sst25vf032b",
+	.parts		= ktt30_spiflash_part,
+	.nr_parts	= ARRAY_SIZE(ktt30_spiflash_part),
+};
+
+static struct tegra_spi_device_controller_data ktt30_spiflash_cdata = {
+	.is_hw_based_cs		= false,
+	.cs_setup_clk_count	= 7,
+	.cs_hold_clk_count	= 15,
+};
+
+static struct spi_board_info __initdata ktt30_spi_info[] = {
+	{
+		.modalias		= "m25p80",
+		.platform_data		= &ktt30_spiflash_data,
+		.controller_data	= &ktt30_spiflash_cdata,
+		.mode			= SPI_MODE_0,
+		/*
+		 * FIXME: debugging at lower speed
+		 */
+		.max_speed_hz		= 300000,
+		.bus_num		= 3,
+		.chip_select		= 1,
+	},
+};
+
+static void __init ktt30_spi_init(void)
+{
+	int i;
+	struct clk *c;
+
+	for (i = 0; i < ARRAY_SIZE(spi_parent_clk); ++i) {
+		c = tegra_get_clock_by_name(spi_parent_clk[i].name);
+		if (IS_ERR_OR_NULL(c)) {
+			pr_err("Not able to get the clock for %s\n",
+						spi_parent_clk[i].name);
+			continue;
+		}
+		spi_parent_clk[i].parent_clk = c;
+		spi_parent_clk[i].fixed_clk_rate = clk_get_rate(c);
+	}
+	ktt30_spi_pdata.parent_clk_list = spi_parent_clk;
+	ktt30_spi_pdata.parent_clk_count = ARRAY_SIZE(spi_parent_clk);
+	tegra_spi_device4.dev.platform_data = &ktt30_spi_pdata;
+	platform_add_devices(ktt30_spi_devices,
+				ARRAY_SIZE(ktt30_spi_devices));
+
+	spi_register_board_info(ktt30_spi_info, ARRAY_SIZE(ktt30_spi_info));
+}
+
+static struct resource tegra_rtc_resources[] = {
+	[0] = {
+		.start = TEGRA_RTC_BASE,
+		.end = TEGRA_RTC_BASE + TEGRA_RTC_SIZE - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = INT_RTC,
+		.end = INT_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device tegra_rtc_device = {
+	.name = "tegra_rtc",
+	.id   = -1,
+	.resource = tegra_rtc_resources,
+	.num_resources = ARRAY_SIZE(tegra_rtc_resources),
+};
+
+static struct tegra_asoc_platform_data ktt30_audio_wm8903_pdata = {
+	.gpio_spkr_en		= TEGRA_GPIO_SPKR_EN,
+	.gpio_hp_det		= TEGRA_GPIO_HP_DET,
+	.gpio_hp_mute		= -1,
+	.gpio_int_mic_en	= -1,
+	.gpio_ext_mic_en	= -1,
+	.i2s_param[HIFI_CODEC]	= {
+		.audio_port_id	= 0,
+		.is_i2s_master	= 1,
+		.i2s_mode	= TEGRA_DAIFMT_I2S,
+	},
+	.i2s_param[BASEBAND]	= {
+		.audio_port_id	= -1,
+	},
+	.i2s_param[BT_SCO]	= {
+		.audio_port_id	= 3,
+		.is_i2s_master	= 1,
+		.i2s_mode	= TEGRA_DAIFMT_DSP_A,
+	},
+};
+
+static struct platform_device ktt30_audio_wm8903_device = {
+	.name	= "tegra-snd-wm8903",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &ktt30_audio_wm8903_pdata,
+	},
+};
+
+static struct platform_device *ktt30_devices[] __initdata = {
+	&tegra_pmu_device,
+	&tegra_rtc_device,
+#if defined(CONFIG_TEGRA_IOVMM_SMMU) ||  defined(CONFIG_TEGRA_IOMMU_SMMU)
+	&tegra_smmu_device,
+#endif
+	&tegra_wdt0_device,
+	&tegra_wdt1_device,
+	&tegra_wdt2_device,
+#if defined(CONFIG_TEGRA_AVP)
+	&tegra_avp_device,
+#endif
+	&tegra_camera,
+#if defined(CONFIG_CRYPTO_DEV_TEGRA_SE)
+	&tegra_se_device,
+#endif
+	&tegra_ahub_device,
+	&tegra_dam_device0,
+	&tegra_dam_device1,
+	&tegra_dam_device2,
+	&tegra_i2s_device0,
+	&tegra_i2s_device1,
+	&tegra_i2s_device3,
+	&tegra_spdif_device,
+	&spdif_dit_device,
+	&bluetooth_dit_device,
+	&baseband_dit_device,
+	&tegra_pcm_device,
+	&ktt30_audio_wm8903_device,
+	&tegra_hda_device,
+#if defined(CONFIG_CRYPTO_DEV_TEGRA_AES)
+	&tegra_aes_device,
+#endif
+};
+
+#define MXT_CONFIG_CRC  0xD62DE8
+static const u8 config[] = {
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xFF, 0xFF, 0x32, 0x0A, 0x00, 0x14, 0x14, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00,
+	0x1B, 0x2A, 0x00, 0x20, 0x3C, 0x04, 0x05, 0x00,
+	0x02, 0x01, 0x00, 0x0A, 0x0A, 0x0A, 0x0A, 0xFF,
+	0x02, 0x55, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23,
+	0x00, 0x00, 0x00, 0x05, 0x0A, 0x15, 0x1E, 0x00,
+	0x00, 0x04, 0xFF, 0x03, 0x3F, 0x64, 0x64, 0x01,
+	0x0A, 0x14, 0x28, 0x4B, 0x00, 0x02, 0x00, 0x64,
+	0x00, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x08, 0x10, 0x3C, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static struct mxt_platform_data atmel_mxt_info = {
+	.x_line         = 27,
+	.y_line         = 42,
+	.x_size         = 768,
+	.y_size         = 1366,
+	.blen           = 0x20,
+	.threshold      = 0x3C,
+	.voltage        = 3300000,              /* 3.3V */
+	.orient         = 5,
+	.config         = config,
+	.config_length  = 157,
+	.config_crc     = MXT_CONFIG_CRC,
+	.irqflags       = IRQF_TRIGGER_FALLING,
+/*	.read_chg       = &read_chg, */
+	.read_chg       = NULL,
+};
+
+static struct i2c_board_info __initdata atmel_i2c_info[] = {
+	{
+		I2C_BOARD_INFO("atmel_mxt_ts", 0x5A),
+		.irq = TEGRA_GPIO_TO_IRQ(TEGRA_GPIO_PH4),
+		.platform_data = &atmel_mxt_info,
+	}
+};
+
+static int __init ktt30_touch_init(void)
+{
+	tegra_gpio_enable(TEGRA_GPIO_PH4);
+	tegra_gpio_enable(TEGRA_GPIO_PH6);
+
+	gpio_request(TEGRA_GPIO_PH4, "atmel-irq");
+	gpio_direction_input(TEGRA_GPIO_PH4);
+
+	gpio_request(TEGRA_GPIO_PH6, "atmel-reset");
+	gpio_direction_output(TEGRA_GPIO_PH6, 0);
+	msleep(1);
+	gpio_set_value(TEGRA_GPIO_PH6, 1);
+	msleep(100);
+
+	i2c_register_board_info(1, atmel_i2c_info, 1);
+
+	return 0;
+}
+
+#if CONFIG_USB_SUPPORT
+static struct tegra_usb_platform_data tegra_udc_pdata = {
+	.port_otg = true,
+	.has_hostpc = true,
+	.phy_intf = TEGRA_USB_PHY_INTF_UTMI,
+	.op_mode = TEGRA_USB_OPMODE_DEVICE,
+	.u_data.dev = {
+		.vbus_pmu_irq = 0,
+		.vbus_gpio = -1,
+		.charging_supported = false,
+		.remote_wakeup_supported = false,
+	},
+	.u_cfg.utmi = {
+		.hssync_start_delay = 0,
+		.elastic_limit = 16,
+		.idle_wait_delay = 17,
+		.term_range_adj = 6,
+		.xcvr_setup = 8,
+		.xcvr_lsfslew = 2,
+		.xcvr_lsrslew = 2,
+		.xcvr_setup_offset = 0,
+		.xcvr_use_fuses = 1,
+	},
+};
+
+static struct tegra_usb_platform_data tegra_ehci1_utmi_pdata = {
+	.port_otg = true,
+	.has_hostpc = true,
+	.phy_intf = TEGRA_USB_PHY_INTF_UTMI,
+	.op_mode = TEGRA_USB_OPMODE_HOST,
+	.u_data.host = {
+		.vbus_gpio = -1,
+		.vbus_reg = "vdd_vbus_micro_usb",
+		.hot_plug = true,
+		.remote_wakeup_supported = true,
+		.power_off_on_suspend = true,
+	},
+	.u_cfg.utmi = {
+		.hssync_start_delay = 0,
+		.elastic_limit = 16,
+		.idle_wait_delay = 17,
+		.term_range_adj = 6,
+		.xcvr_setup = 15,
+		.xcvr_lsfslew = 2,
+		.xcvr_lsrslew = 2,
+		.xcvr_setup_offset = 0,
+		.xcvr_use_fuses = 1,
+	},
+};
+
+static struct tegra_usb_platform_data tegra_ehci2_utmi_pdata = {
+	.port_otg = false,
+	.has_hostpc = true,
+	.phy_intf = TEGRA_USB_PHY_INTF_UTMI,
+	.op_mode	= TEGRA_USB_OPMODE_HOST,
+	.u_data.host = {
+		.vbus_gpio = -1,
+		.hot_plug = true,
+		.remote_wakeup_supported = true,
+		.power_off_on_suspend = true,
+	},
+	.u_cfg.utmi = {
+		.hssync_start_delay = 0,
+		.elastic_limit = 16,
+		.idle_wait_delay = 17,
+		.term_range_adj = 6,
+		.xcvr_setup = 15,
+		.xcvr_lsfslew = 2,
+		.xcvr_lsrslew = 2,
+		.xcvr_setup_offset = 0,
+		.xcvr_use_fuses = 1,
+	},
+};
+
+static struct tegra_usb_platform_data tegra_ehci3_utmi_pdata = {
+	.port_otg = false,
+	.has_hostpc = true,
+	.phy_intf = TEGRA_USB_PHY_INTF_UTMI,
+	.op_mode	= TEGRA_USB_OPMODE_HOST,
+	.u_data.host = {
+		.vbus_gpio = -1,
+		.vbus_reg = "vdd_vbus_typea_usb",
+		.hot_plug = true,
+		.remote_wakeup_supported = true,
+		.power_off_on_suspend = true,
+	},
+	.u_cfg.utmi = {
+		.hssync_start_delay = 0,
+		.elastic_limit = 16,
+		.idle_wait_delay = 17,
+		.term_range_adj = 6,
+		.xcvr_setup = 8,
+		.xcvr_lsfslew = 2,
+		.xcvr_lsrslew = 2,
+		.xcvr_setup_offset = 0,
+		.xcvr_use_fuses = 1,
+	},
+};
+
+static struct tegra_usb_otg_data tegra_otg_pdata = {
+	.ehci_device = &tegra_ehci1_device,
+	.ehci_pdata = &tegra_ehci1_utmi_pdata,
+};
+
+/* OTG should be the first to be registered */
+static struct platform_device __initdata *ktt30_usb_devices[] = {
+	&tegra_otg_device,
+	&tegra_udc_device,
+	&tegra_ehci2_device,
+	&tegra_ehci3_device,
+};
+
+static void ktt30_usb_init(void)
+{
+	tegra_otg_device.dev.platform_data = &tegra_otg_pdata;
+	tegra_udc_device.dev.platform_data = &tegra_udc_pdata;
+	tegra_ehci2_device.dev.platform_data = &tegra_ehci2_utmi_pdata;
+	tegra_ehci3_device.dev.platform_data = &tegra_ehci3_utmi_pdata;
+
+	platform_add_devices(ktt30_usb_devices, ARRAY_SIZE(ktt30_usb_devices));
+}
+#else
+static void ktt30_usb_init(void) { }
+#endif
+
+static void ktt30_gps_init(void)
+{
+	tegra_gpio_enable(TEGRA_GPIO_PU2);
+	tegra_gpio_enable(TEGRA_GPIO_PU3);
+}
+
+static void ktt30_nfc_init(void)
+{
+	tegra_gpio_enable(TEGRA_GPIO_PX0);
+	tegra_gpio_enable(TEGRA_GPIO_PP3);
+	tegra_gpio_enable(TEGRA_GPIO_PO7);
+}
+
+static struct tegra_pci_platform_data ktt30_pci_platform_data = {
+	.port_status[0]	= 1,
+	.port_status[1]	= 1,
+	.port_status[2]	= 1,
+	.use_dock_detect	= 0,
+	.gpio		= -1,
+};
+
+static void ktt30_pci_init(void)
+{
+	tegra_pci_device.dev.platform_data = &ktt30_pci_platform_data;
+	platform_device_register(&tegra_pci_device);
+}
+
+#ifdef CONFIG_SATA_AHCI_TEGRA
+static void ktt30_sata_init(void)
+{
+	platform_device_register(&tegra_sata_device);
+}
+#else
+static void ktt30_sata_init(void) { }
+#endif
+
+static void __init tegra_ktt30_init(void)
+{
+	tegra_thermal_init(&thermal_data,
+				throttle_list,
+				ARRAY_SIZE(throttle_list));
+	tegra_clk_init_from_table(ktt30_clk_init_table);
+	ktt30_pinmux_init();
+	ktt30_i2c_init();
+	ktt30_spi_init();
+	ktt30_usb_init();
+#ifdef CONFIG_TEGRA_EDP_LIMITS
+	ktt30_edp_init();
+#endif
+	ktt30_uart_init();
+	platform_add_devices(ktt30_devices, ARRAY_SIZE(ktt30_devices));
+	tegra_ram_console_debug_init();
+	tegra_io_dpd_init();
+	ktt30_sdhci_init();
+	ktt30_regulator_init();
+	ktt30_suspend_init();
+	ktt30_touch_init();
+	ktt30_gps_init();
+	ktt30_panel_init();
+	ktt30_pmon_init();
+	ktt30_sensors_init();
+	ktt30_sata_init();
+	//audio_wired_jack_init();
+	ktt30_pins_state_init();
+	ktt30_emc_init();
+	tegra_release_bootloader_fb();
+	ktt30_nfc_init();
+	ktt30_pci_init();
+#ifdef CONFIG_TEGRA_WDT_RECOVERY
+	tegra_wdt_recovery_init();
+#endif
+}
+
+static void __init tegra_ktt30_reserve(void)
+{
+#if defined(CONFIG_NVMAP_CONVERT_CARVEOUT_TO_IOVMM)
+	/* support 1920X1200 with 24bpp */
+	tegra_reserve(0, SZ_8M + SZ_1M, SZ_8M + SZ_1M);
+#else
+	tegra_reserve(SZ_128M, SZ_8M, SZ_8M);
+#endif
+	tegra_ram_console_debug_reserve(SZ_1M);
+}
+
+static const char *ktt30_dt_board_compat[] = {
+	"kontron,ktt30",
+	NULL
+};
+
+MACHINE_START(KTT30, "ktt30")
+	.boot_params    = 0x80000100,
+	.map_io         = tegra_map_common_io,
+	.reserve        = tegra_ktt30_reserve,
+	.init_early	= tegra_init_early,
+	.init_irq       = tegra_init_irq,
+	.timer          = &tegra_timer,
+	.init_machine   = tegra_ktt30_init,
+	.dt_compat	= ktt30_dt_board_compat,
+MACHINE_END
--- /dev/null
+++ b/arch/arm/mach-tegra/board-ktt30.h
@@ -0,0 +1,85 @@
+/*
+ * arch/arm/mach-tegra/board-ktt30.h
+ *
+ * Copyright (c) 2011, NVIDIA Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef _MACH_TEGRA_BOARD_KTT30_H
+#define _MACH_TEGRA_BOARD_KTT30_H
+
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <linux/mfd/tps6591x.h>
+
+/* External peripheral act as gpio */
+/* TPS6591x GPIOs */
+#define TPS6591X_GPIO_BASE	TEGRA_NR_GPIOS
+#define TPS6591X_GPIO_0		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP0)
+#define TPS6591X_GPIO_1		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP1)
+#define TPS6591X_GPIO_2		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP2)
+#define TPS6591X_GPIO_3		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP3)
+#define TPS6591X_GPIO_4		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP4)
+#define TPS6591X_GPIO_5		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP5)
+#define TPS6591X_GPIO_6		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP6)
+#define TPS6591X_GPIO_7		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP7)
+#define TPS6591X_GPIO_8		(TPS6591X_GPIO_BASE + TPS6591X_GPIO_GP8)
+#define TPS6591X_GPIO_END	(TPS6591X_GPIO_BASE + TPS6591X_GPIO_NR)
+
+/* WM8903 GPIOs */
+#define KTT30_GPIO_WM8903(_x_)		(TPS6591X_GPIO_END + 32 + (_x_))
+#define KTT30_GPIO_WM8903_END		KTT30_GPIO_WM8903(4)
+
+/* Audio-related GPIOs */
+#define TEGRA_GPIO_SPKR_EN		KTT30_GPIO_WM8903(2)
+#define TEGRA_GPIO_HP_DET		TEGRA_GPIO_PW2
+
+#define AC_PRESENT_GPIO			TPS6591X_GPIO_4
+
+/*****************Interrupt tables ******************/
+/* External peripheral act as interrupt controller */
+/* TPS6591x IRQs */
+#define TPS6591X_IRQ_BASE	TEGRA_NR_IRQS
+#define TPS6591X_IRQ_END	(TPS6591X_IRQ_BASE + 18)
+#define DOCK_DETECT_GPIO TEGRA_GPIO_PU4
+
+int ktt30_regulator_init(void);
+int ktt30_suspend_init(void);
+int ktt30_sdhci_init(void);
+int ktt30_pinmux_init(void);
+int ktt30_panel_init(void);
+int ktt30_sensors_init(void);
+int ktt30_pins_state_init(void);
+int ktt30_emc_init(void);
+int ktt30_edp_init(void);
+int ktt30_pmon_init(void);
+
+#define MPU_TYPE_MPU3050	1
+#define MPU_GYRO_TYPE		MPU_TYPE_MPU3050
+#define MPU_GYRO_NAME		"mpu3050"
+#define MPU_GYRO_IRQ_GPIO	TEGRA_GPIO_PX1
+#define MPU_GYRO_ADDR		0x68
+#define MPU_GYRO_BUS_NUM	2
+#define MPU_GYRO_ORIENTATION	{ 0, -1, 0, -1, 0, 0, 0, 0, -1 }
+#define MPU_ACCEL_NAME		"kxtf9"
+#define MPU_ACCEL_IRQ_GPIO	TEGRA_GPIO_PL1
+#define MPU_ACCEL_ADDR		0x0F
+#define MPU_ACCEL_BUS_NUM	2
+#define MPU_ACCEL_ORIENTATION	{ 0, -1, 0, -1, 0, 0, 0, 0, -1 }
+
+#define TDIODE_OFFSET  (10000) /* in millicelsius */
+
+#endif
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1204,3 +1204,4 @@ baileys			MACH_BAILEYS		BAILEYS			4169
 familybox		MACH_FAMILYBOX		FAMILYBOX		4170
 ensemble_mx35		MACH_ENSEMBLE_MX35	ENSEMBLE_MX35		4171
 sc_sps_1		MACH_SC_SPS_1		SC_SPS_1		4172
+ktt30			MACH_KTT30		KTT30			4228
