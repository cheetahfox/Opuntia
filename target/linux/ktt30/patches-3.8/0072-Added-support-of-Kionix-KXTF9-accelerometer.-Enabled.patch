From 4a8b32995a80f804b34f06cbd2171512e208b27c Mon Sep 17 00:00:00 2001
From: Maxim Yu. Osipov <mosipov@dev.rtsoft.ru>
Date: Tue, 16 Apr 2013 18:52:23 +0400
Subject: [PATCH 072/127] Added support of Kionix KXTF9 accelerometer. Enabled
 interrupts in MPU3050 driver.

The kxtf9.c is based on mpu3050.c. This a 'lite' version of the driver, which
exposes raw orientation data to user space via /dev/input/<event> interface.

Signed-off-by: Maxim Osipov <mosipov@dev.rtsoft.ru>
Signed-off-by: Valentine Barshak <vbarshak@dev.rtsoft.ru>
---
 drivers/input/misc/Kconfig   |   10 +
 drivers/input/misc/Makefile  |    1 +
 drivers/input/misc/kxtf9.c   |  444 ++++++++++++++++++++++++++++++++++++++++++
 drivers/input/misc/mpu3050.c |   30 +++
 4 files changed, 485 insertions(+), 0 deletions(-)
 create mode 100644 drivers/input/misc/kxtf9.c

--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -197,6 +197,16 @@ config INPUT_MPU3050
 	  To compile this driver as a module, choose M here: the
 	  module will be called mpu3050.
 
+config INPUT_KXTF9
+	tristate "KXTF9 Triaxial Accelerometer"
+	depends on I2C
+	help
+	  Say Y here if you want to support Kionix KXTF9
+	  connected via an I2C bus.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called kxtf9.
+
 config INPUT_APANEL
 	tristate "Fujitsu Lifebook Application Panel buttons"
 	depends on X86 && I2C && LEDS_CLASS
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_INPUT_MAX8997_HAPTIC)	+= ma
 obj-$(CONFIG_INPUT_MC13783_PWRBUTTON)	+= mc13783-pwrbutton.o
 obj-$(CONFIG_INPUT_MMA8450)		+= mma8450.o
 obj-$(CONFIG_INPUT_MPU3050)		+= mpu3050.o
+obj-$(CONFIG_INPUT_KXTF9)		+= kxtf9.o
 obj-$(CONFIG_INPUT_PCAP)		+= pcap_keys.o
 obj-$(CONFIG_INPUT_PCF50633_PMU)	+= pcf50633-input.o
 obj-$(CONFIG_INPUT_PCF8574)		+= pcf8574_keypad.o
--- /dev/null
+++ b/drivers/input/misc/kxtf9.c
@@ -0,0 +1,444 @@
+/*
+ * KXTF9 Tri-axis accelerometer driver
+ *
+ * Copyright (C) 2013 Kontron AG
+ *
+ * This is a 'lite' version of the driver, while we consider the right way
+ * to present the other features to user space. In particular it requires the
+ * device has an IRQ, and it only provides an input interface, so is not much
+ * use for device orientation.
+ *
+ * This program is based on mpu3050.c.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+
+#define KXTF9_XOUT_HPF_L	0x0
+#define KXTF9_CHIP_ID_REG	0x0F
+#define KXTF9_CHIP_ID		0x01
+
+#define KXTF9_INT_REL		0x1A
+#define KXTF9_CTRL_REG1		0x1B
+
+#define CTRL_REG1_TPE		(1 << 0)
+#define CTRL_REG1_WUFE		(1 << 1)
+#define CTRL_REG1_TDTE		(1 << 2)
+#define CTRL_REG1_GSEL0		(1 << 3)
+#define CTRL_REG1_GSEL1		(1 << 4)
+#define CTRL_REG1_DRDYE		(1 << 5)
+#define CTRL_REG1_RES		(1 << 6)
+#define CTRL_REG1_PC1		(1 << 7)
+
+#define KXTF9_CTRL_REG2		0x1C
+
+#define CTRL_REG2_FUM		(1 << 0)
+#define CTRL_REG2_FDM		(1 << 1)
+#define CTRL_REG2_UPM		(1 << 2)
+#define CTRL_REG2_DOM		(1 << 3)
+#define CTRL_REG2_RIM		(1 << 4)
+#define CTRL_REG2_LEM		(1 << 5)
+
+#define KXTF9_CTRL_REG3		0x1D
+
+#define CTRL_REG3_OWUFB		(1 << 0)
+#define CTRL_REG3_OWUFA		(1 << 1)
+#define CTRL_REG3_OTDTB		(1 << 2)
+#define CTRL_REG3_OTDTA		(1 << 3)
+#define CTRL_REG3_DCST		(1 << 4)
+#define CTRL_REG3_OTPB		(1 << 5)
+#define CTRL_REG3_OTPA		(1 << 6)
+#define CTRL_REG3_SRST		(1 << 7)
+
+#define KXTF9_INT_CTRL_REG1		0x1E
+
+#define INT_CTRL_REG1_IEU		(1 << 2)
+#define INT_CTRL_REG1_IEL		(1 << 3)
+#define INT_CTRL_REG1_IEA		(1 << 4)
+#define INT_CTRL_REG1_IEN		(1 << 5)
+
+#define KXTF9_INT_CTRL_REG2		0x1F
+
+#define INT_CTRL_REG2_XBM		(1 << 5)
+#define INT_CTRL_REG2_YBM		(1 << 6)
+#define INT_CTRL_REG2_ZBM		(1 << 7)
+
+#define KXTF9_INT_CTRL_REG3		0x20
+
+#define INT_CTRL_REG3_OWUFB		(1 << 0)
+#define INT_CTRL_REG3_OWUFA		(1 << 1)
+#define INT_CTRL_REG3_OTDTB		(1 << 2)
+#define INT_CTRL_REG3_OTDTA		(1 << 3)
+#define INT_CTRL_REG3_DCST		(1 << 4)
+#define INT_CTRL_REG3_OTPB		(1 << 5)
+
+#define KXTF9_AUTO_DELAY	1000
+
+#define KXTF9_MIN_VALUE		-2048
+#define KXTF9_MAX_VALUE		2047
+
+struct axis_data {
+	s16 x;
+	s16 y;
+	s16 z;
+};
+
+struct kxtf9_sensor {
+	struct i2c_client *client;
+	struct device *dev;
+	struct input_dev *idev;
+};
+
+/**
+ *	kxtf9_xyz_read_reg	-	read the axes values
+ *	@buffer: provide register addr and get register
+ *	@length: length of register
+ *
+ *	Reads the register values in one transaction or returns a negative
+ *	error code on failure.
+ */
+static int kxtf9_xyz_read_reg(struct i2c_client *client,
+			       u8 *buffer, int length)
+{
+	/*
+	 * Annoying we can't make this const because the i2c layer doesn't
+	 * declare input buffers const.
+	 */
+	char cmd = KXTF9_XOUT_HPF_L;
+	struct i2c_msg msg[] = {
+		{
+			.addr = client->addr,
+			.flags = 0,
+			.len = 1,
+			.buf = &cmd,
+		},
+		{
+			.addr = client->addr,
+			.flags = I2C_M_RD,
+			.len = length,
+			.buf = buffer,
+		},
+	};
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+/**
+ *	kxtf9_read_xyz	-	get co-ordinates from device
+ *	@client: i2c address of sensor
+ *	@coords: co-ordinates to update
+ *
+ *	Return the converted X Y and Z co-ordinates from the sensor device
+ */
+static void kxtf9_read_xyz(struct i2c_client *client,
+			     struct axis_data *coords)
+{
+	u16 buffer[3];
+
+	kxtf9_xyz_read_reg(client, (u8 *)buffer, 6);
+	coords->x = le16_to_cpu(((s16)buffer[0]) >> 4);
+	coords->y = le16_to_cpu(((s16)buffer[1]) >> 4);
+	coords->z = le16_to_cpu(((s16)buffer[2]) >> 4);
+	dev_dbg(&client->dev, "%s: x %d, y %d, z %d\n", __func__,
+					coords->x, coords->y, coords->z);
+}
+
+/**
+ *	kxtf9_set_power_mode	-	set the power mode
+ *	@client: i2c client for the sensor
+ *	@val: value to switch on/off of power, 1: normal power, 0: low power
+ *
+ *	Put device to normal-power mode or low-power mode.
+ */
+static void kxtf9_set_power_mode(struct i2c_client *client, u8 val)
+{
+	u8 value;
+
+	value = i2c_smbus_read_byte_data(client, KXTF9_CTRL_REG1);
+
+	if (val)
+		value |= CTRL_REG1_PC1;
+	else
+		value &= ~CTRL_REG1_PC1;
+
+	i2c_smbus_write_byte_data(client, KXTF9_CTRL_REG1, value);
+}
+
+/**
+ *	kxtf9_input_open	-	called on input event open
+ *	@input: input dev of opened device
+ *
+ *	The input layer calls this function when input event is opened. The
+ *	function will push the device to resume. Then, the device is ready
+ *	to provide data.
+ */
+static int kxtf9_input_open(struct input_dev *input)
+{
+	struct kxtf9_sensor *sensor = input_get_drvdata(input);
+
+	pm_runtime_get(sensor->dev);
+
+	return 0;
+}
+
+/**
+ *	kxtf9_input_close	-	called on input event close
+ *	@input: input dev of closed device
+ *
+ *	The input layer calls this function when input event is closed. The
+ *	function will push the device to suspend.
+ */
+static void kxtf9_input_close(struct input_dev *input)
+{
+	struct kxtf9_sensor *sensor = input_get_drvdata(input);
+
+	pm_runtime_put(sensor->dev);
+}
+
+/**
+ *	kxtf9_interrupt_thread	-	handle an IRQ
+ *	@irq: interrupt numner
+ *	@data: the sensor
+ *
+ *	Called by the kernel single threaded after an interrupt occurs. Read
+ *	the sensor data and generate an input event for it.
+ */
+static irqreturn_t kxtf9_interrupt_thread(int irq, void *data)
+{
+	struct kxtf9_sensor *sensor = data;
+	struct axis_data axis;
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(sensor->client, KXTF9_INT_REL);
+
+	kxtf9_read_xyz(sensor->client, &axis);
+
+	input_report_abs(sensor->idev, ABS_X, axis.x);
+	input_report_abs(sensor->idev, ABS_Y, axis.y);
+	input_report_abs(sensor->idev, ABS_Z, axis.z);
+	input_sync(sensor->idev);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ *	kxtf9_probe	-	device detection callback
+ *	@client: i2c client of found device
+ *	@id: id match information
+ *
+ *	The I2C layer calls us when it believes a sensor is present at this
+ *	address. Probe to see if this is correct and to validate the device.
+ *
+ *	If present install the relevant sysfs interfaces and input device.
+ */
+static int __devinit kxtf9_probe(struct i2c_client *client,
+				   const struct i2c_device_id *id)
+{
+	struct kxtf9_sensor *sensor;
+	struct input_dev *idev;
+	int ret;
+	int error;
+
+	sensor = kzalloc(sizeof(struct kxtf9_sensor), GFP_KERNEL);
+	idev = input_allocate_device();
+	if (!sensor || !idev) {
+		dev_err(&client->dev, "failed to allocate driver data\n");
+		error = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	sensor->client = client;
+	sensor->dev = &client->dev;
+	sensor->idev = idev;
+
+	ret = i2c_smbus_read_byte_data(client, KXTF9_CHIP_ID_REG);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to detect device\n");
+		error = -ENXIO;
+		goto err_free_mem;
+	}
+
+	if (ret != KXTF9_CHIP_ID) {
+		dev_err(&client->dev, "unsupported chip id\n");
+		error = -ENXIO;
+		goto err_free_mem;
+	}
+
+	idev->name = "KXTF9";
+	idev->id.bustype = BUS_I2C;
+	idev->dev.parent = &client->dev;
+
+	idev->open = kxtf9_input_open;
+	idev->close = kxtf9_input_close;
+
+	__set_bit(EV_ABS, idev->evbit);
+	input_set_abs_params(idev, ABS_X,
+			     KXTF9_MIN_VALUE, KXTF9_MAX_VALUE, 0, 0);
+	input_set_abs_params(idev, ABS_Y,
+			     KXTF9_MIN_VALUE, KXTF9_MAX_VALUE, 0, 0);
+	input_set_abs_params(idev, ABS_Z,
+			     KXTF9_MIN_VALUE, KXTF9_MAX_VALUE, 0, 0);
+
+	input_set_drvdata(idev, sensor);
+
+	pm_runtime_set_active(&client->dev);
+
+	error = request_threaded_irq(client->irq,
+				     NULL, kxtf9_interrupt_thread,
+				     IRQF_TRIGGER_RISING,
+				     "accel_int", sensor);
+	if (error) {
+		dev_err(&client->dev,
+			"can't get IRQ %d, error %d\n", client->irq, error);
+		goto err_pm_set_suspended;
+	}
+
+	error = input_register_device(idev);
+	if (error) {
+		dev_err(&client->dev, "failed to register input device\n");
+		goto err_free_irq;
+	}
+
+	pm_runtime_enable(&client->dev);
+	pm_runtime_set_autosuspend_delay(&client->dev, KXTF9_AUTO_DELAY);
+
+	ret = i2c_smbus_write_byte_data(client, KXTF9_INT_CTRL_REG1,
+		INT_CTRL_REG1_IEN | INT_CTRL_REG1_IEA);
+
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to enable interrupt\n");
+		error = -ENXIO;
+		goto err_free_irq;
+	}
+
+	ret = i2c_smbus_write_byte_data(client, KXTF9_CTRL_REG1,
+		CTRL_REG1_PC1 | CTRL_REG1_DRDYE | CTRL_REG1_TDTE |
+		CTRL_REG1_WUFE | CTRL_REG1_TPE);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to setup CTRL_REG1\n");
+		error = -ENXIO;
+		goto err_free_mem;
+	}
+
+	return 0;
+
+err_free_irq:
+	free_irq(client->irq, sensor);
+err_pm_set_suspended:
+	pm_runtime_set_suspended(&client->dev);
+err_free_mem:
+	input_free_device(idev);
+	kfree(sensor);
+	return error;
+}
+
+/**
+ *	kxtf9_remove	-	remove a sensor
+ *	@client: i2c client of sensor being removed
+ *
+ *	Our sensor is going away, clean up the resources.
+ */
+static int __devexit kxtf9_remove(struct i2c_client *client)
+{
+	struct kxtf9_sensor *sensor = i2c_get_clientdata(client);
+
+	pm_runtime_disable(&client->dev);
+	pm_runtime_set_suspended(&client->dev);
+
+	free_irq(client->irq, sensor);
+	input_unregister_device(sensor->idev);
+	kfree(sensor);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/**
+ *	kxtf9_suspend		-	called on device suspend
+ *	@dev: device being suspended
+ *
+ *	Put the device into sleep mode before we suspend the machine.
+ */
+static int kxtf9_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	kxtf9_set_power_mode(client, 0);
+
+	return 0;
+}
+
+/**
+ *	kxtf9_resume		-	called on device resume
+ *	@dev: device being resumed
+ *
+ *	Put the device into powered mode on resume.
+ */
+static int kxtf9_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+
+	kxtf9_set_power_mode(client, 1);
+	msleep(100);  /* wait for chip resume */
+
+	return 0;
+}
+#endif
+
+static UNIVERSAL_DEV_PM_OPS(kxtf9_pm, kxtf9_suspend, kxtf9_resume, NULL);
+
+static const struct i2c_device_id kxtf9_ids[] = {
+	{ "kxtf9", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, kxtf9_ids);
+
+static struct i2c_driver kxtf9_i2c_driver = {
+	.driver	= {
+		.name	= "kxtf9",
+		.owner	= THIS_MODULE,
+		.pm	= &kxtf9_pm,
+	},
+	.probe		= kxtf9_probe,
+	.remove		= __devexit_p(kxtf9_remove),
+	.id_table	= kxtf9_ids,
+};
+
+static int __init kxtf9_init(void)
+{
+	return i2c_add_driver(&kxtf9_i2c_driver);
+}
+module_init(kxtf9_init);
+
+static void __exit kxtf9_exit(void)
+{
+	i2c_del_driver(&kxtf9_i2c_driver);
+}
+module_exit(kxtf9_exit);
+
+MODULE_AUTHOR("Kontron AG");
+MODULE_DESCRIPTION("KXTF9 Tri-axis Accelerometer driver");
+MODULE_LICENSE("GPL");
--- a/drivers/input/misc/mpu3050.c
+++ b/drivers/input/misc/mpu3050.c
@@ -42,6 +42,18 @@
 #include <linux/pm_runtime.h>
 
 #define MPU3050_CHIP_ID		0x69
+#define MPU3050_XOFFS_USRH	0xC
+#define MPU3050_SMPLRT_DIV	0x15
+
+#define INT_RAW_RDY_EN		(1 << 0)
+#define INT_DMP_DONE_EN		(1 << 1)
+#define INT_MPU_RDY_EN		(1 << 2)
+#define INT_ANTRDY_2CLR		(1 << 4)
+#define INT_LATCH_EN		(1 << 5)
+#define INT_OPEN		(1 << 6)
+#define INT_ACTL		(1 << 7)
+
+#define MPU3050_INT_STATUS	0x1A
 
 #define MPU3050_AUTO_DELAY	1000
 
@@ -384,6 +396,23 @@ static int mpu3050_probe(struct i2c_clie
 	pm_runtime_enable(&client->dev);
 	pm_runtime_set_autosuspend_delay(&client->dev, MPU3050_AUTO_DELAY);
 
+	ret = i2c_smbus_write_byte_data(client, MPU3050_SMPLRT_DIV, 0xff);
+
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to setup sample rate divider\n");
+		error = -ENXIO;
+		goto err_free_irq;
+	}
+
+	ret = i2c_smbus_write_byte_data(client,
+					 MPU3050_INT_CFG, INT_RAW_RDY_EN);
+
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to enable interrupt\n");
+		error = -ENXIO;
+		goto err_free_irq;
+	}
+
 	return 0;
 
 err_free_irq:
